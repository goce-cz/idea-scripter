import Enumeration = require('nashorn/java/util/Enumeration');
import TreeNode = require('nashorn/javax/swing/tree/TreeNode');
import Object = require('nashorn/java/lang/Object');
import MutableTreeNode = require('nashorn/javax/swing/tree/MutableTreeNode');
import ObjectOutputStream = require('nashorn/java/io/ObjectOutputStream');
import ObjectInputStream = require('nashorn/java/io/ObjectInputStream');
import Cloneable = require('nashorn/java/lang/Cloneable');
import Serializable = require('nashorn/java/io/Serializable');

declare class DefaultMutableTreeNode {
	static EMPTY_ENUMERATION : Enumeration<TreeNode>;
	parent : TreeNode;
	childCount : number;
	allowsChildren : boolean;
	userObject : Object;
	depth : number;
	level : number;
	path : TreeNode[];
	userObjectPath : Object[];
	root : TreeNode;
	nextNode : DefaultMutableTreeNode;
	previousNode : DefaultMutableTreeNode;
	firstChild : TreeNode;
	lastChild : TreeNode;
	siblingCount : number;
	nextSibling : DefaultMutableTreeNode;
	previousSibling : DefaultMutableTreeNode;
	leaf : boolean;
	firstLeaf : DefaultMutableTreeNode;
	lastLeaf : DefaultMutableTreeNode;
	nextLeaf : DefaultMutableTreeNode;
	previousLeaf : DefaultMutableTreeNode;
	leafCount : number;
	constructor();
	constructor(arg1 : Object);
	constructor(arg1 : Object, arg2 : boolean);
	setAllowsChildren(arg1 : boolean) : void;
	getUserObject() : Object;
	removeAllChildren() : void;
	add(arg1 : MutableTreeNode) : void;
	isNodeAncestor(arg1 : TreeNode) : boolean;
	isNodeDescendant(arg1 : DefaultMutableTreeNode) : boolean;
	getSharedAncestor(arg1 : DefaultMutableTreeNode) : TreeNode;
	isNodeRelated(arg1 : DefaultMutableTreeNode) : boolean;
	getDepth() : number;
	getLevel() : number;
	getPath() : TreeNode[];
	getPathToRoot(arg1 : TreeNode, arg2 : number) : TreeNode[];
	getUserObjectPath() : Object[];
	getRoot() : TreeNode;
	isRoot() : boolean;
	getNextNode() : DefaultMutableTreeNode;
	getPreviousNode() : DefaultMutableTreeNode;
	preorderEnumeration() : Enumeration;
	postorderEnumeration() : Enumeration;
	breadthFirstEnumeration() : Enumeration;
	depthFirstEnumeration() : Enumeration;
	pathFromAncestorEnumeration(arg1 : TreeNode) : Enumeration;
	isNodeChild(arg1 : TreeNode) : boolean;
	getFirstChild() : TreeNode;
	getLastChild() : TreeNode;
	getChildAfter(arg1 : TreeNode) : TreeNode;
	getChildBefore(arg1 : TreeNode) : TreeNode;
	isNodeSibling(arg1 : TreeNode) : boolean;
	getSiblingCount() : number;
	getNextSibling() : DefaultMutableTreeNode;
	getPreviousSibling() : DefaultMutableTreeNode;
	getFirstLeaf() : DefaultMutableTreeNode;
	getLastLeaf() : DefaultMutableTreeNode;
	getNextLeaf() : DefaultMutableTreeNode;
	getPreviousLeaf() : DefaultMutableTreeNode;
	getLeafCount() : number;
	writeObject(arg1 : ObjectOutputStream) : void;
	readObject(arg1 : ObjectInputStream) : void;
}


declare interface DefaultMutableTreeNode extends Cloneable, MutableTreeNode, Serializable {}

declare module DefaultMutableTreeNode {
	class BreadthFirstEnumeration {
		constructor(arg1 : TreeNode);
	}


	interface BreadthFirstEnumeration extends Enumeration<TreeNode> {}

	module BreadthFirstEnumeration {
		class Queue extends Object {
			empty : boolean;
			enqueue(arg1 : Object) : void;
			dequeue() : Object;
			firstObject() : Object;
			isEmpty() : boolean;
		}


		module Queue {
			class QNode extends Object {
				object : Object;
				next : DefaultMutableTreeNode.BreadthFirstEnumeration.Queue.QNode;
				constructor(arg1 : Object, arg2 : DefaultMutableTreeNode.BreadthFirstEnumeration.Queue.QNode);
			}
		}
	}
	class PathBetweenNodesEnumeration {
		constructor(arg1 : TreeNode, arg2 : TreeNode);
	}


	interface PathBetweenNodesEnumeration extends Enumeration<TreeNode> {}	class PostorderEnumeration {
		constructor(arg1 : TreeNode);
	}


	interface PostorderEnumeration extends Enumeration<TreeNode> {}	class PreorderEnumeration {
		constructor(arg1 : TreeNode);
	}


	interface PreorderEnumeration extends Enumeration<TreeNode> {}}

export = DefaultMutableTreeNode
