import Object = require('nashorn/java/lang/Object');
import Void = require('nashorn/java/lang/Void');
import RuntimeException = require('nashorn/java/lang/RuntimeException');
import Throwable = require('nashorn/java/lang/Throwable');
import Collection = require('nashorn/java/util/Collection');
import ActionCallback = require('nashorn/com/intellij/openapi/util/ActionCallback');
import AsyncResult = require('nashorn/com/intellij/openapi/util/AsyncResult');
import Consumer = require('nashorn/com/intellij/util/Consumer');
import AsyncPromise = require('nashorn/org/jetbrains/concurrency/AsyncPromise');
import Function = require('nashorn/com/intellij/util/Function');
import AsyncFunction = require('nashorn/org/jetbrains/concurrency/AsyncFunction');
import Enum = require('nashorn/java/lang/Enum');

declare class Promise<T> extends Object {
	static DONE : Promise<Void>;
	static REJECTED : Promise<Void>;
	state : Promise.State;
	constructor();
	static createError(arg1 : string) : RuntimeException;
	static resolve<T>(arg1 : T) : Promise<T>;
	static reject<T>(arg1 : string) : Promise<T>;
	static reject<T>(arg1 : Throwable) : Promise<T>;
	static all(arg1 : Collection<Promise<any>>) : Promise<Void>;
	static all<T>(arg1 : Collection<Promise<any>>, arg2 : T) : Promise<T>;
	static wrapAsVoid(arg1 : ActionCallback) : Promise<Void>;
	static wrap<T>(arg1 : AsyncResult<T>) : Promise<T>;
	done(arg1 : Consumer<T>) : Promise<T>;
	processed(arg1 : AsyncPromise<T>) : Promise<T>;
	rejected(arg1 : Consumer<Throwable>) : Promise<T>;
	processed(arg1 : Consumer<T>) : Promise<T>;
	then<SUB_RESULT>(arg1 : Function<T, SUB_RESULT>) : Promise<SUB_RESULT>;
	then<SUB_RESULT>(arg1 : AsyncFunction<T, SUB_RESULT>) : Promise<SUB_RESULT>;
	getState() : Promise.State;
	notify(arg1 : AsyncPromise<T>) : void;
}


declare module Promise {
	class MessageError {
		constructor(arg1 : string);
	}


	interface MessageError extends RuntimeException {}	class State {
		static PENDING : Promise.State;
		static FULFILLED : Promise.State;
		static REJECTED : Promise.State;
	}


	interface State extends Enum<Promise.State> {}}

export = Promise
