import Function = require('nashorn/com/intellij/util/Function');
import Consumer = require('nashorn/com/intellij/util/Consumer');
import ActionCallback = require('nashorn/com/intellij/openapi/util/ActionCallback');
import PairConsumer = require('nashorn/com/intellij/util/PairConsumer');
import List = require('nashorn/java/util/List');
import Object = require('nashorn/java/lang/Object');

declare class AsyncResult<T> {
	result : T;
	resultSync : T;
	constructor();
	setDone(arg1 : T) : AsyncResult<T>;
	setRejected(arg1 : T) : AsyncResult<T>;
	subResult<DependentResult>(arg1 : Function<T, DependentResult>) : AsyncResult<DependentResult>;
	subResult<SubResult, SubAsyncResult extends AsyncResult<SubResult>>(arg1 : SubAsyncResult, arg2 : Function<T, SubResult>) : SubAsyncResult;
	subCallback(arg1 : Consumer<T>) : ActionCallback;
	doWhenDone(arg1 : AsyncResult.Handler<T>) : AsyncResult<T>;
	doWhenDone(arg1 : Consumer<T>) : AsyncResult<T>;
	doWhenRejected(arg1 : AsyncResult.Handler<T>) : AsyncResult<T>;
	doWhenRejected(arg1 : PairConsumer<T, string>) : AsyncResult<T>;
	getResult() : T;
	getResultSync() : T;
	getResultSync(arg1 : number) : T;
	doWhenProcessed(arg1 : Consumer<T>) : ActionCallback;
	static rejected<R>() : AsyncResult<R>;
	static rejected<R>(arg1 : string) : AsyncResult<R>;
	static done<R>(arg1 : R) : AsyncResult<R>;
	static doneList<R extends List>() : AsyncResult<R>;
}


declare interface AsyncResult<T> extends ActionCallback {}

declare module AsyncResult {
	class SubCallbackDoneCallback<Result> {
		constructor(arg1 : ActionCallback, arg2 : Consumer<Result>);
	}


	interface SubCallbackDoneCallback<Result> extends Consumer<Result> {}	class SubResultDoneCallback<Result, SubResult, AsyncSubResult extends AsyncResult<SubResult>> {
		constructor(arg1 : AsyncSubResult, arg2 : Function<Result, SubResult>);
	}


	interface SubResultDoneCallback<Result, SubResult, AsyncSubResult extends AsyncResult<SubResult>> extends Consumer<Result> {}	class Rejected<T> {
		constructor();
		constructor(arg1 : T);
	}


	interface Rejected<T> extends AsyncResult<T> {}	class Done<T> {
		constructor(arg1 : T);
	}


	interface Done<T> extends AsyncResult<T> {}	class Handler<T> extends Object {
		run(arg1 : T) : void;
	}
}

export = AsyncResult
