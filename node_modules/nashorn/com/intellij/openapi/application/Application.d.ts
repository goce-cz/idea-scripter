import ModalityInvokator = require('nashorn/com/intellij/openapi/application/ModalityInvokator');
import ModalityState = require('nashorn/com/intellij/openapi/application/ModalityState');
import Runnable = require('nashorn/java/lang/Runnable');
import Computable = require('nashorn/com/intellij/openapi/util/Computable');
import Throwable = require('nashorn/java/lang/Throwable');
import ThrowableComputable = require('nashorn/com/intellij/openapi/util/ThrowableComputable');
import Class = require('nashorn/java/lang/Class');
import ApplicationListener = require('nashorn/com/intellij/openapi/application/ApplicationListener');
import Disposable = require('nashorn/com/intellij/openapi/Disposable');
import Condition = require('nashorn/com/intellij/openapi/util/Condition');
import Component = require('nashorn/java/awt/Component');
import Future = require('nashorn/java/util/concurrent/Future');
import Callable = require('nashorn/java/util/concurrent/Callable');
import AccessToken = require('nashorn/com/intellij/openapi/application/AccessToken');
import ComponentManager = require('nashorn/com/intellij/openapi/components/ComponentManager');

declare class Application {
	writeAccessAllowed : boolean;
	readAccessAllowed : boolean;
	dispatchThread : boolean;
	invokator : ModalityInvokator;
	currentModalityState : ModalityState;
	defaultModalityState : ModalityState;
	noneModalityState : ModalityState;
	anyModalityState : ModalityState;
	startTime : number;
	idleTime : number;
	unitTestMode : boolean;
	headlessEnvironment : boolean;
	commandLine : boolean;
	disposed : boolean;
	disposeInProgress : boolean;
	restartCapable : boolean;
	active : boolean;
	internal : boolean;
	eAP : boolean;
	runReadAction(arg1 : Runnable) : void;
	runReadAction<T>(arg1 : Computable<T>) : T;
	runReadAction<T, E extends Throwable>(arg1 : ThrowableComputable<T, E>) : T;
	runWriteAction(arg1 : Runnable) : void;
	runWriteAction<T>(arg1 : Computable<T>) : T;
	runWriteAction<T, E extends Throwable>(arg1 : ThrowableComputable<T, E>) : T;
	hasWriteAction(arg1 : Class<any>) : boolean;
	assertReadAccessAllowed() : void;
	assertWriteAccessAllowed() : void;
	assertIsDispatchThread() : void;
	addApplicationListener(arg1 : ApplicationListener) : void;
	addApplicationListener(arg1 : ApplicationListener, arg2 : Disposable) : void;
	removeApplicationListener(arg1 : ApplicationListener) : void;
	saveAll() : void;
	saveSettings() : void;
	exit() : void;
	isWriteAccessAllowed() : boolean;
	isReadAccessAllowed() : boolean;
	isDispatchThread() : boolean;
	getInvokator() : ModalityInvokator;
	invokeLater(arg1 : Runnable) : void;
	invokeLater(arg1 : Runnable, arg2 : Condition) : void;
	invokeLater(arg1 : Runnable, arg2 : ModalityState) : void;
	invokeLater(arg1 : Runnable, arg2 : ModalityState, arg3 : Condition) : void;
	invokeAndWait(arg1 : Runnable, arg2 : ModalityState) : void;
	getCurrentModalityState() : ModalityState;
	getModalityStateForComponent(arg1 : Component) : ModalityState;
	getDefaultModalityState() : ModalityState;
	getNoneModalityState() : ModalityState;
	getAnyModalityState() : ModalityState;
	getStartTime() : number;
	getIdleTime() : number;
	isUnitTestMode() : boolean;
	isHeadlessEnvironment() : boolean;
	isCommandLine() : boolean;
	executeOnPooledThread(arg1 : Runnable) : Future<any>;
	executeOnPooledThread<T>(arg1 : Callable<T>) : Future<T>;
	isDisposeInProgress() : boolean;
	isRestartCapable() : boolean;
	restart() : void;
	isActive() : boolean;
	acquireReadActionLock() : AccessToken;
	acquireWriteActionLock(arg1 : Class) : AccessToken;
	isInternal() : boolean;
	isEAP() : boolean;
}


declare interface Application extends ComponentManager {}
export = Application
