import List = require('nashorn/java/util/List');
import ScriptingLibraryModel = require('nashorn/com/intellij/webcore/libraries/ScriptingLibraryModel');
import Project = require('nashorn/com/intellij/openapi/project/Project');
import ScriptingLibraryManager = require('nashorn/com/intellij/webcore/libraries/ScriptingLibraryManager');
import LibraryTable = require('nashorn/com/intellij/openapi/roots/libraries/LibraryTable');
import Disposable = require('nashorn/com/intellij/openapi/Disposable');
import VirtualFile = require('nashorn/com/intellij/openapi/vfs/VirtualFile');
import Consumer = require('nashorn/com/intellij/util/Consumer');
import Set = require('nashorn/java/util/Set');
import Module = require('nashorn/com/intellij/openapi/module/Module');
import MappingsChangeListener = require('nashorn/com/intellij/webcore/libraries/MappingsChangeListener');
import LanguagePerFileMappings = require('nashorn/com/intellij/lang/LanguagePerFileMappings');
import Collection = require('nashorn/java/util/Collection');

declare class ScriptingLibraryMappings {
	singleLibraries : List<ScriptingLibraryModel>;
	constructor(arg1 : Project);
	getLibraryManager() : ScriptingLibraryManager;
	registerLibraryTableListener(arg1 : LibraryTable.Listener, arg2 : Disposable) : void;
	reset() : void;
	updateMappings() : void;
	associate(arg1 : VirtualFile, arg2 : string, arg3 : boolean) : void;
	associateWithProject(arg1 : string) : void;
	disassociateWithProject(arg1 : string) : void;
	associate(arg1 : VirtualFile, arg2 : string) : void;
	disassociate(arg1 : VirtualFile, arg2 : string) : void;
	isAssociatedWithProject(arg1 : string) : boolean;
	isAssociatedWith(arg1 : VirtualFile, arg2 : string) : boolean;
	isLibraryInScopeFor(arg1 : VirtualFile, arg2 : string) : boolean;
	containsLibraryName(arg1 : ScriptingLibraryModel, arg2 : string) : boolean;
	getSingleLibraries() : List<ScriptingLibraryModel>;
	isApplicable(arg1 : VirtualFile, arg2 : VirtualFile) : boolean;
	isRecursivelyApplicable(arg1 : VirtualFile, arg2 : VirtualFile) : boolean;
	iterateUp(arg1 : VirtualFile, arg2 : Consumer<VirtualFile>) : void;
	getLibraryFilesFor(arg1 : VirtualFile) : Set<VirtualFile>;
	getAllLibrariesInScope(arg1 : VirtualFile) : Set<ScriptingLibraryModel>;
	containsProjectLibrary(arg1 : string) : boolean;
	containsLibrary(arg1 : ScriptingLibraryModel) : boolean;
	dependsOn(arg1 : Module, arg2 : ScriptingLibraryModel, arg3 : number) : boolean;
	getMappingsByLibraryName(arg1 : string) : List<VirtualFile>;
	isLibraryApplicableForFile(arg1 : string, arg2 : VirtualFile) : boolean;
	static isFileInScope(arg1 : List<VirtualFile>, arg2 : VirtualFile) : boolean;
	addMappingsChangeListener(arg1 : MappingsChangeListener) : void;
	removeMappingsChangeListener(arg1 : MappingsChangeListener) : void;
	fireOnAssociated(arg1 : VirtualFile, arg2 : string, arg3 : boolean) : void;
	fireOnDisassociated(arg1 : VirtualFile, arg2 : string) : void;
}


declare interface ScriptingLibraryMappings extends LanguagePerFileMappings<ScriptingLibraryModel>, LibraryTable.Listener, Disposable {}

declare module ScriptingLibraryMappings {
	class CompoundLibrary {
		name : string;
		libraries : Collection<ScriptingLibraryModel>;
		empty : boolean;
		libraryCount : number;
		modified : boolean;
		sourceFiles : Set<VirtualFile>;
		compactFiles : Set<VirtualFile>;
		constructor();
		clearLibraries() : void;
		toggleLibrary(arg1 : ScriptingLibraryModel) : void;
		addLibrary(arg1 : ScriptingLibraryModel) : void;
		containsLibrary(arg1 : string) : boolean;
		serialize() : string;
		getLibraries() : Collection<ScriptingLibraryModel>;
		getLibraryCount() : number;
		applyChanges() : void;
		isModified() : boolean;
		reset() : void;
	}


	interface CompoundLibrary extends ScriptingLibraryModel {}}

export = ScriptingLibraryMappings
