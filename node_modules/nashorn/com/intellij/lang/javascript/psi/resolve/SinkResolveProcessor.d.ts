import ResultSink = require('nashorn/com/intellij/lang/javascript/psi/resolve/ResultSink');
import PsiElement = require('nashorn/com/intellij/psi/PsiElement');
import List = require('nashorn/java/util/List');
import ResolveResult = require('nashorn/com/intellij/psi/ResolveResult');
import ReadWriteAccessDetector = require('nashorn/com/intellij/codeInsight/highlighting/ReadWriteAccessDetector');
import ResolveProcessor = require('nashorn/com/intellij/lang/javascript/psi/resolve/ResolveProcessor');

declare class SinkResolveProcessor<T extends ResultSink> {
	result : PsiElement;
	results : List<PsiElement>;
	placeTopParent : PsiElement;
	resultsAsResolveResults : ResolveResult[];
	resultSink : T;
	constructor(arg1 : T);
	constructor(arg1 : string, arg2 : boolean, arg3 : T);
	constructor(arg1 : string, arg2 : T);
	constructor(arg1 : string, arg2 : PsiElement, arg3 : T);
	getResult() : PsiElement;
	getResults() : List<PsiElement>;
	getPlaceTopParent() : PsiElement;
	setForcedPackageName(arg1 : string) : void;
	setCheckArgumentTypes(arg1 : boolean) : void;
	addPossibleCandidateResult(arg1 : PsiElement, arg2 : string) : void;
	elementIsNotAccessible(arg1 : PsiElement) : void;
	checkParameterTypes(arg1 : PsiElement) : PsiElement;
	doSetterProcessing(arg1 : PsiElement) : ReadWriteAccessDetector.Access;
	static getElement(arg1 : PsiElement) : PsiElement;
	getResultsAsResolveResults() : ResolveResult[];
	addResult(arg1 : PsiElement) : void;
	getResultSink() : T;
}


declare interface SinkResolveProcessor<T extends ResultSink> extends ResolveProcessor {}
export = SinkResolveProcessor
