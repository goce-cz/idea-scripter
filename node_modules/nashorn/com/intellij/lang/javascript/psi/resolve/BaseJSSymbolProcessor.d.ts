import GlobalSearchScope = require('nashorn/com/intellij/psi/search/GlobalSearchScope');
import JSElement = require('nashorn/com/intellij/lang/javascript/psi/JSElement');
import JSSymbolNamespace = require('nashorn/com/intellij/lang/javascript/psi/JSSymbolNamespace');
import JSQualifiedName = require('nashorn/com/intellij/lang/javascript/psi/JSQualifiedName');
import VirtualFile = require('nashorn/com/intellij/openapi/vfs/VirtualFile');
import JSPsiElementBase = require('nashorn/com/intellij/lang/javascript/psi/JSPsiElementBase');
import JSExpression = require('nashorn/com/intellij/lang/javascript/psi/JSExpression');
import PsiElement = require('nashorn/com/intellij/psi/PsiElement');
import JSType = require('nashorn/com/intellij/lang/javascript/psi/JSType');
import JSClass = require('nashorn/com/intellij/lang/javascript/psi/ecmal4/JSClass');
import JSContext = require('nashorn/com/intellij/lang/javascript/psi/types/JSContext');
import List = require('nashorn/java/util/List');
import PsiScopeProcessor = require('nashorn/com/intellij/psi/scope/PsiScopeProcessor');
import Object = require('nashorn/java/lang/Object');
import ResolveProcessor = require('nashorn/com/intellij/lang/javascript/psi/resolve/ResolveProcessor');
import PsiFile = require('nashorn/com/intellij/psi/PsiFile');
import JSReferenceExpression = require('nashorn/com/intellij/lang/javascript/psi/JSReferenceExpression');
import JSObjectLiteralExpression = require('nashorn/com/intellij/lang/javascript/psi/JSObjectLiteralExpression');
import Enum = require('nashorn/java/lang/Enum');
import Set = require('nashorn/java/util/Set');
import Collection = require('nashorn/java/util/Collection');
import JSRecordTypeImpl = require('nashorn/com/intellij/lang/javascript/psi/types/JSRecordTypeImpl');

declare class BaseJSSymbolProcessor {
	static HTML_ELEMENT_TYPE_NAME : string;
	static EMPTY_CONTEXT : string[];
	requiredName : string;
	limitingScope : GlobalSearchScope;
	typeInfo : BaseJSSymbolProcessor.TypeInfo;
	globalContext : boolean;
	getRequiredName() : string;
	calculateContextNames(arg1 : JSElement) : JSSymbolNamespace;
	addOnlyCompleteMatches() : boolean;
	setAddOnlyCompleteMatches(arg1 : boolean) : void;
	isGlobalNS(arg1 : JSQualifiedName, arg2 : boolean) : boolean;
	acceptsFile(arg1 : VirtualFile) : boolean;
	isFromRelevantFileOrDirectory() : boolean;
	getLimitingScope() : GlobalSearchScope;
	resetLimitingScope() : void;
	toCheckFileLevelAccess() : boolean;
	isAcceptable(arg1 : JSPsiElementBase) : boolean;
	static getOriginalQualifier(arg1 : JSExpression) : JSExpression;
	isStrictTypingPossible(arg1 : PsiElement, arg2 : JSType) : boolean;
	static isValidType(arg1 : string) : boolean;
	addPackageScope(arg1 : JSClass, arg2 : PsiElement) : void;
	addAllParentScopes(arg1 : string) : void;
	buildIndexListFromQNameAndCorrectQName(arg1 : string) : string;
	buildIndexListFromQNameAndCorrectQName(arg1 : string, arg2 : boolean, arg3 : JSContext) : string;
	static addIndexListFromQName(arg1 : string, arg2 : List<string>) : string;
	getContextScopeNames() : string[];
	doIterateTypeHierarchy(arg1 : string[], arg2 : BaseJSSymbolProcessor.HierarchyProcessor) : void;
	buildQualifiedNameFromContextIds(arg1 : string[]) : string;
	doIterateHierarchy(arg1 : string, arg2 : BaseJSSymbolProcessor.HierarchyProcessor) : void;
	getTypeInfo() : BaseJSSymbolProcessor.TypeInfo;
	isGlobalContext() : boolean;
}


declare interface BaseJSSymbolProcessor extends PsiScopeProcessor {}

declare module BaseJSSymbolProcessor {
	class TagContextBuilder extends Object {
		element : PsiElement;
		typeName : string;
		constructor(arg1 : PsiElement, arg2 : string);
	}
	class SimpleTypeProcessor {
		target : PsiElement;
		type : JSType;
		source : PsiElement;
		constructor();
		constructor(arg1 : PsiElement);
		addPossibleOption(arg1 : JSType) : void;
		getType() : JSType;
		getSource() : PsiElement;
	}


	interface SimpleTypeProcessor extends ResolveProcessor, BaseJSSymbolProcessor.TypeProcessor, BaseJSSymbolProcessor.GenericTypeParametersClient {}	class GenericTypeParametersClient extends Object {
	}
	class TypeProcessor extends Object {
		target : PsiElement;
		process(arg1 : JSType, arg2 : BaseJSSymbolProcessor.EvaluateContext, arg3 : PsiElement) : void;
		getTarget() : PsiElement;
		setUnknownElement(arg1 : PsiElement) : void;
		setLimitedTo(arg1 : PsiFile, arg2 : boolean) : void;
	}
	class EvaluateContext extends Object {
		targetFile : PsiFile;
		qualifier : JSReferenceExpression;
		source : PsiElement;
		constructor(arg1 : PsiFile);
		isAlreadyProcessingItem(arg1 : PsiElement) : boolean;
		getQualifier() : JSReferenceExpression;
		setQualifier(arg1 : JSReferenceExpression) : void;
		addProcessingItem(arg1 : PsiElement) : void;
		removeProcessingItem(arg1 : PsiElement) : void;
		getSource() : PsiElement;
		setSource(arg1 : PsiElement) : void;
		alreadyProcessed(arg1 : string) : boolean;
		ensureProcessed(arg1 : string) : boolean;
	}
	class HierarchyProcessor extends Object {
		processNamespace(arg1 : string, arg2 : VirtualFile) : boolean;
		processClass(arg1 : JSClass) : boolean;
		processObjectLiteral(arg1 : JSObjectLiteralExpression) : boolean;
	}
	class MatchType {
		static COMPLETE_WITH_CONTEXT : BaseJSSymbolProcessor.MatchType;
		static COMPLETE : BaseJSSymbolProcessor.MatchType;
		static COMPLETE_PREDEFINED : BaseJSSymbolProcessor.MatchType;
		static COMPLETE_NS : BaseJSSymbolProcessor.MatchType;
		static PARTIAL : BaseJSSymbolProcessor.MatchType;
		static NOMATCH : BaseJSSymbolProcessor.MatchType;
	}


	interface MatchType extends Enum<BaseJSSymbolProcessor.MatchType> {}	class MatchMode {
		static Any : BaseJSSymbolProcessor.MatchMode;
		static Strict : BaseJSSymbolProcessor.MatchMode;
	}


	interface MatchMode extends Enum<BaseJSSymbolProcessor.MatchMode> {}	class TypeInfo extends Object {
		myContextLevels : List<BaseJSSymbolProcessor.TypeInfo.ContextLevel>;
		myBaseObjectLiterals : Set<JSObjectLiteralExpression>;
		myRecordTypes : Collection<JSRecordTypeImpl>;
		empty : boolean;
		constructor();
		addType(arg1 : string[]) : void;
		addType(arg1 : string[], arg2 : boolean, arg3 : JSContext) : void;
		addGlobalType() : void;
		onlyInstanceAccess() : boolean;
		isEmpty() : boolean;
		hasMatchedNamespace(arg1 : JSQualifiedName) : boolean;
		typeAllowAnyProperties() : boolean;
		addBaseObjectLiteral(arg1 : JSObjectLiteralExpression) : void;
		addRecordType(arg1 : JSRecordTypeImpl) : void;
	}


	module TypeInfo {
		class ContextLevel extends Object {
			myQualifiedName : string[];
			myStaticOrInstance : JSContext;
			myRelativeLevel : number;
		}
	}
	class GlobalStatusHint {
		static GLOBAL : BaseJSSymbolProcessor.GlobalStatusHint;
		static NONGLOBAL : BaseJSSymbolProcessor.GlobalStatusHint;
		static INSIDE_MODULE : BaseJSSymbolProcessor.GlobalStatusHint;
		static UNKNOWN : BaseJSSymbolProcessor.GlobalStatusHint;
	}


	interface GlobalStatusHint extends Enum<BaseJSSymbolProcessor.GlobalStatusHint> {}}

export = BaseJSSymbolProcessor
