import Object = require('nashorn/java/lang/Object');
import BaseJSSymbolProcessor = require('nashorn/com/intellij/lang/javascript/psi/resolve/BaseJSSymbolProcessor');
import PsiElement = require('nashorn/com/intellij/psi/PsiElement');
import JSExpression = require('nashorn/com/intellij/lang/javascript/psi/JSExpression');
import PsiFile = require('nashorn/com/intellij/psi/PsiFile');
import JSType = require('nashorn/com/intellij/lang/javascript/psi/JSType');
import JSNewExpression = require('nashorn/com/intellij/lang/javascript/psi/JSNewExpression');
import JSCallExpression = require('nashorn/com/intellij/lang/javascript/psi/JSCallExpression');
import JSReferenceExpression = require('nashorn/com/intellij/lang/javascript/psi/JSReferenceExpression');
import JSFunction = require('nashorn/com/intellij/lang/javascript/psi/JSFunction');
import JSVariable = require('nashorn/com/intellij/lang/javascript/psi/JSVariable');
import JSProperty = require('nashorn/com/intellij/lang/javascript/psi/JSProperty');
import JSQualifiedNamedElement = require('nashorn/com/intellij/lang/javascript/psi/ecmal4/JSQualifiedNamedElement');
import JSForInStatement = require('nashorn/com/intellij/lang/javascript/psi/JSForInStatement');
import JSParameter = require('nashorn/com/intellij/lang/javascript/psi/JSParameter');
import JSNamedElement = require('nashorn/com/intellij/lang/javascript/psi/JSNamedElement');
import JSObjectLiteralExpression = require('nashorn/com/intellij/lang/javascript/psi/JSObjectLiteralExpression');
import SinkResolveProcessor = require('nashorn/com/intellij/lang/javascript/psi/resolve/SinkResolveProcessor');
import JSDefinitionExpression = require('nashorn/com/intellij/lang/javascript/psi/JSDefinitionExpression');
import Set = require('nashorn/java/util/Set');

declare class JSTypeEvaluator extends Object {
	static MAX_RESOLVE_RESULT_COUNT_TO_EVALUATE : number;
	constructor(arg1 : BaseJSSymbolProcessor.EvaluateContext, arg2 : BaseJSSymbolProcessor.TypeProcessor, arg3 : boolean);
	static forceEvaluateType(arg1 : PsiElement, arg2 : JSExpression, arg3 : PsiFile) : JSType;
	static evaluateTypes(arg1 : JSExpression, arg2 : PsiFile, arg3 : BaseJSSymbolProcessor.TypeProcessor) : void;
	static evaluateType(arg1 : JSExpression, arg2 : PsiFile) : JSType;
	addType(arg1 : JSType, arg2 : PsiElement) : void;
	addType(arg1 : string, arg2 : PsiElement) : void;
	addType(arg1 : string, arg2 : PsiElement, arg3 : boolean) : void;
	evaluateTypes(arg1 : JSExpression) : void;
	getArrayTypeFromExpressions(arg1 : JSExpression, arg2 : JSExpression[]) : JSType;
	evaluateDialectSpecificTypes(arg1 : JSExpression) : boolean;
	evaluateNewExpressionTypes(arg1 : JSNewExpression) : void;
	evaluateCallExpressionTypes(arg1 : JSCallExpression) : JSExpression;
	addTypeFromExternalModuleReferenceResolveResult(arg1 : JSReferenceExpression, arg2 : PsiElement) : void;
	addDefaultExportNamespaces(arg1 : PsiElement) : void;
	evalExprType(arg1 : JSExpression) : JSType;
	createSubEvaluator(arg1 : BaseJSSymbolProcessor.TypeProcessor) : JSTypeEvaluator;
	processFunction(arg1 : JSExpression, arg2 : JSFunction) : boolean;
	processRefExpr(arg1 : JSReferenceExpression) : void;
	addTypeFromResolveResult(arg1 : JSReferenceExpression, arg2 : PsiElement, arg3 : PsiElement, arg4 : boolean) : boolean;
	qualifierTypeIsExplicitlyDeclared(arg1 : JSExpression) : boolean;
	addTypeFromVariableResolveResult(arg1 : JSReferenceExpression, arg2 : JSVariable) : void;
	useVariableType(arg1 : JSType) : boolean;
	areFromSameFiles(arg1 : PsiElement, arg2 : PsiElement) : boolean;
	addTypeFromElementResolveResult(arg1 : JSReferenceExpression, arg2 : PsiElement, arg3 : PsiElement, arg4 : boolean) : boolean;
	addTypeFromProperty(arg1 : JSProperty, arg2 : JSReferenceExpression, arg3 : PsiElement) : boolean;
	addTypeFromQualifiedNamedElement(arg1 : JSQualifiedNamedElement) : void;
	addTypeFromClass(arg1 : JSReferenceExpression, arg2 : PsiElement, arg3 : PsiElement) : void;
	getLoopVarType(arg1 : JSReferenceExpression, arg2 : PsiElement, arg3 : JSForInStatement) : JSType;
	addTypeFromDialectSpecificElements(arg1 : JSReferenceExpression, arg2 : PsiElement) : boolean;
	evalComponentTypeFromArrayExpression(arg1 : JSExpression, arg2 : JSExpression) : JSType;
	addComponentTypeFromProcessor(arg1 : JSExpression, arg2 : JSType) : JSType;
	static processParameterType(arg1 : JSParameter, arg2 : JSType) : JSType;
	static getTypeIfAmdModuleReference(arg1 : JSParameter) : JSType;
	addTypeFromConstant(arg1 : JSExpression) : void;
	static getTypeFromConstant(arg1 : JSExpression, arg2 : boolean) : JSType;
	addAdditionalTypes(arg1 : JSReferenceExpression, arg2 : JSReferenceExpression) : void;
	tryAddBindowsType(arg1 : JSReferenceExpression) : void;
	static isBindowsXml(arg1 : PsiFile) : boolean;
	static getElementQName(arg1 : JSNamedElement) : string;
	addTypeFromObjectLiteralExpression(arg1 : JSObjectLiteralExpression, arg2 : boolean) : void;
	findDef(arg1 : JSReferenceExpression, arg2 : SinkResolveProcessor) : boolean;
	addTypeFromDefExpr(arg1 : JSReferenceExpression, arg2 : JSDefinitionExpression) : void;
	tryAddTypeFromInitializerReference(arg1 : PsiElement) : boolean;
	tryAddTypeFromInitializerReference(arg1 : PsiElement, arg2 : Set<PsiElement>) : boolean;
	simpleEvalType(arg1 : JSExpression, arg2 : JSExpression) : void;
}

export = JSTypeEvaluator
