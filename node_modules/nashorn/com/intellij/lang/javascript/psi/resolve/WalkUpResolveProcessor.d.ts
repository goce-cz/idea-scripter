import PsiFile = require('nashorn/com/intellij/psi/PsiFile');
import ResolveResult = require('nashorn/com/intellij/psi/ResolveResult');
import List = require('nashorn/java/util/List');
import PsiElement = require('nashorn/com/intellij/psi/PsiElement');
import BaseJSSymbolProcessor = require('nashorn/com/intellij/lang/javascript/psi/resolve/BaseJSSymbolProcessor');
import JSPsiElementBase = require('nashorn/com/intellij/lang/javascript/psi/JSPsiElementBase');
import EnumSet = require('nashorn/java/util/EnumSet');
import JSDefinitionExpression = require('nashorn/com/intellij/lang/javascript/psi/JSDefinitionExpression');
import SinkResolveProcessor = require('nashorn/com/intellij/lang/javascript/psi/resolve/SinkResolveProcessor');
import ResolveResultSink = require('nashorn/com/intellij/lang/javascript/psi/resolve/ResolveResultSink');
import Enum = require('nashorn/java/lang/Enum');
import Comparable = require('nashorn/java/lang/Comparable');

declare class WalkUpResolveProcessor {
	baseFile : PsiFile;
	requiredName : string;
	results : ResolveResult[];
	taggedResolveResults : List<WalkUpResolveProcessor.TaggedResolveResult>;
	constructor(arg1 : string, arg2 : string[], arg3 : PsiFile, arg4 : PsiElement, arg5 : BaseJSSymbolProcessor.MatchMode);
	iterateContextIds(arg1 : string[], arg2 : boolean) : void;
	isAcceptableQualifiedItem(arg1 : JSPsiElementBase) : BaseJSSymbolProcessor.MatchType;
	doUnqualifiedCheck(arg1 : PsiElement) : void;
	doQualifiedCheck(arg1 : JSPsiElementBase) : void;
	addCompleteResult(arg1 : PsiElement) : void;
	addCompleteResult(arg1 : ResolveResult) : void;
	addCompleteResultWithProblem(arg1 : PsiElement, arg2 : string) : void;
	addPartialResult(arg1 : PsiElement, arg2 : string) : void;
	addResult(arg1 : ResolveResult, arg2 : EnumSet<WalkUpResolveProcessor.ResolveResultTag>) : void;
	static isFromMinifiedFile(arg1 : PsiElement) : boolean;
	getBaseFile() : PsiFile;
	static handleDefinitionWithHigherPriority(arg1 : JSDefinitionExpression) : boolean;
	allowPartialResults() : void;
	getResults() : ResolveResult[];
	static filterSimilarDefinitions(arg1 : List<WalkUpResolveProcessor.TaggedResolveResult>) : List<WalkUpResolveProcessor.TaggedResolveResult>;
	static convertResults(arg1 : List<WalkUpResolveProcessor.TaggedResolveResult>) : ResolveResult[];
	getTaggedResolveResults() : List<WalkUpResolveProcessor.TaggedResolveResult>;
	addLocalResults(arg1 : SinkResolveProcessor<ResolveResultSink>) : void;
	setSkipDefinitions(arg1 : boolean) : void;
}


declare interface WalkUpResolveProcessor extends BaseJSSymbolProcessor {}

declare module WalkUpResolveProcessor {
	class ResolveResultTag {
		static CURRENT_FILE : WalkUpResolveProcessor.ResolveResultTag;
		static PARTIAL : WalkUpResolveProcessor.ResolveResultTag;
		static MINOR_IMPORTANCE : WalkUpResolveProcessor.ResolveResultTag;
		static DEFINITION : WalkUpResolveProcessor.ResolveResultTag;
		static JSDOC_DEFINED : WalkUpResolveProcessor.ResolveResultTag;
		static CONTEXT_MATCHES : WalkUpResolveProcessor.ResolveResultTag;
	}


	interface ResolveResultTag extends Enum<WalkUpResolveProcessor.ResolveResultTag> {}	class TaggedResolveResult {
		comparePriorityTo(arg1 : WalkUpResolveProcessor.TaggedResolveResult) : number;
		hasTag(arg1 : WalkUpResolveProcessor.ResolveResultTag) : boolean;
	}


	interface TaggedResolveResult extends Comparable<WalkUpResolveProcessor.TaggedResolveResult> {}}

export = WalkUpResolveProcessor
