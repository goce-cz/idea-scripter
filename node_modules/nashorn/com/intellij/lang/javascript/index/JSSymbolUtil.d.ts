import Object = require('nashorn/java/lang/Object');
import JSExpression = require('nashorn/com/intellij/lang/javascript/psi/JSExpression');
import PsiElement = require('nashorn/com/intellij/psi/PsiElement');
import JSPsiElementBase = require('nashorn/com/intellij/lang/javascript/psi/JSPsiElementBase');
import JSObjectLiteralExpression = require('nashorn/com/intellij/lang/javascript/psi/JSObjectLiteralExpression');
import JSElement = require('nashorn/com/intellij/lang/javascript/psi/JSElement');
import JSReferenceExpression = require('nashorn/com/intellij/lang/javascript/psi/JSReferenceExpression');
import IElementType = require('nashorn/com/intellij/psi/tree/IElementType');
import Ref = require('nashorn/com/intellij/openapi/util/Ref');
import JSNamespaceEvaluationResult = require('nashorn/com/intellij/lang/javascript/index/JSNamespaceEvaluationResult');
import JSType = require('nashorn/com/intellij/lang/javascript/psi/JSType');
import Set = require('nashorn/java/util/Set');
import JSThisExpression = require('nashorn/com/intellij/lang/javascript/psi/JSThisExpression');
import JSFunctionExpression = require('nashorn/com/intellij/lang/javascript/psi/JSFunctionExpression');
import JSFunction = require('nashorn/com/intellij/lang/javascript/psi/JSFunction');
import PsiQualifiedReference = require('nashorn/com/intellij/psi/PsiQualifiedReference');
import JSQualifiedName = require('nashorn/com/intellij/lang/javascript/psi/JSQualifiedName');
import JSTypeContext = require('nashorn/com/intellij/lang/javascript/psi/types/JSTypeContext');
import JSContext = require('nashorn/com/intellij/lang/javascript/psi/types/JSContext');
import QualifiedName = require('nashorn/com/intellij/psi/util/QualifiedName');
import JSLiteralExpression = require('nashorn/com/intellij/lang/javascript/psi/JSLiteralExpression');
import JSArgumentList = require('nashorn/com/intellij/lang/javascript/psi/JSArgumentList');
import JSCallExpression = require('nashorn/com/intellij/lang/javascript/psi/JSCallExpression');
import JSParameter = require('nashorn/com/intellij/lang/javascript/psi/JSParameter');
import PsiFile = require('nashorn/com/intellij/psi/PsiFile');
import Pair = require('nashorn/com/intellij/openapi/util/Pair');
import TypeScriptTypeMember = require('nashorn/com/intellij/lang/javascript/psi/ecma6/TypeScriptTypeMember');
import JSIndexedPropertyAccessExpression = require('nashorn/com/intellij/lang/javascript/psi/JSIndexedPropertyAccessExpression');
import JSSymbolNamespace = require('nashorn/com/intellij/lang/javascript/psi/JSSymbolNamespace');
import JSProperty = require('nashorn/com/intellij/lang/javascript/psi/JSProperty');

declare class JSSymbolUtil extends Object {
	static J_QUERY_VAR_NAME : string;
	static YAHOO_NAME : string;
	static WINDOW_OBJECT_NAME : string;
	static GLOBAL_OBJECT_NAME2 : string;
	static GLOBAL_OBJECT_NAME3 : string;
	static EXPORTS : string;
	static MODULE : string;
	static MODULE_EXPORTS : string;
	static EXTEND_METHOD_PART : string;
	static DEFINE_METHOD_NAME : string;
	static REQUIRE_METHOD_NAME : string;
	static DECLARE_METHOD_NAME : string;
	static IMPLEMENT_METHOD_NAME : string;
	constructor();
	static symbolSeemsToBeExtensionFunction(arg1 : string) : boolean;
	static findClassesNames(arg1 : JSExpression) : JSExpression[];
	static isDefinitelyConstructor(arg1 : PsiElement) : boolean;
	static isConstructorName(arg1 : string) : boolean;
	static isConstructorSymbol(arg1 : JSPsiElementBase) : boolean;
	static forEachIdentifierProperty(arg1 : JSObjectLiteralExpression, arg2 : JSSymbolUtil.PropertyProcessor) : void;
	static isExtendCallOutsideFunction(arg1 : JSExpression, arg2 : string) : boolean;
	static suggestSetterName(arg1 : string) : string;
	static suggestGetterName(arg1 : string) : string;
	static findNameComponent(arg1 : JSElement) : JSElement;
	static findExportedNameComponent(arg1 : JSElement) : JSElement;
	static buildNameIndexArray(arg1 : JSElement) : string[];
	static visitReferenceExpressionComponentsInRootFirstOrder(arg1 : JSReferenceExpression, arg2 : JSSymbolUtil.ReferenceExpressionProcessor) : void;
	static binaryOpTypeToAvoidRecursions(arg1 : IElementType) : boolean;
	static isMeaningfulLocalVariableInitializer(arg1 : JSExpression) : boolean;
	static isInterface(arg1 : string, arg2 : PsiElement) : boolean;
	static evaluateInitializedPrototype(arg1 : JSElement, arg2 : Ref<JSReferenceExpression>) : JSNamespaceEvaluationResult;
	static createRef(arg1 : string, arg2 : PsiElement) : JSReferenceExpression;
	static evaluateNamespaceLocally(arg1 : JSReferenceExpression) : JSNamespaceEvaluationResult;
	static getPredefinedType(arg1 : JSReferenceExpression) : JSType;
	static getPredefinedNamespace(arg1 : JSReferenceExpression) : JSNamespaceEvaluationResult;
	static createWindowType(arg1 : PsiElement) : JSType;
	static createWindowNamespace(arg1 : JSReferenceExpression, arg2 : boolean) : JSNamespaceEvaluationResult;
	static evaluateNamespaceLocally(arg1 : JSExpression) : JSNamespaceEvaluationResult;
	static evaluateTypeLocally(arg1 : JSExpression) : JSType;
	static evaluateNamespaceLocally(arg1 : JSReferenceExpression, arg2 : Set<string>) : JSNamespaceEvaluationResult;
	static checkAnonymousCallForClassExtension(arg1 : string, arg2 : JSElement) : JSType;
	static calcRefExprValue(arg1 : JSReferenceExpression) : JSElement;
	static calcRefExprValue(arg1 : string, arg2 : JSElement) : JSElement;
	static evalThis(arg1 : JSThisExpression, arg2 : Ref<JSReferenceExpression>) : JSNamespaceEvaluationResult;
	static calcRefExprUsedForClassExtension(arg1 : JSFunctionExpression, arg2 : PsiElement, arg3 : string) : JSReferenceExpression;
	static isReferencingName(arg1 : string, arg2 : JSExpression) : boolean;
	static evaluateReturnedTypeLocally(arg1 : JSFunction) : JSType;
	static replaceLocalVars(arg1 : JSReferenceExpression) : JSNamespaceEvaluationResult;
	static replaceLocalVars(arg1 : JSNamespaceEvaluationResult, arg2 : JSReferenceExpression, arg3 : Set<string>) : JSNamespaceEvaluationResult;
	static isAccurateReferenceExpression(arg1 : JSReferenceExpression) : boolean;
	static isAccurateReferenceExpressionName(arg1 : JSReferenceExpression, arg2 : string[]) : boolean;
	static getAccurateReferenceName(arg1 : PsiQualifiedReference) : JSQualifiedName;
	static createTypeFromReferenceExpression(arg1 : JSReferenceExpression, arg2 : JSTypeContext) : JSType;
	static createNamespaceFromReferenceExpression(arg1 : JSReferenceExpression, arg2 : JSContext, arg3 : boolean) : JSNamespaceEvaluationResult;
	static isPrototype(arg1 : string) : boolean;
	static evaluateReferencedNamespace(arg1 : JSExpression) : QualifiedName;
	static getReferencedNamespace(arg1 : JSExpression) : JSQualifiedName;
	static getLiteralValueAsQualifiedName(arg1 : JSLiteralExpression) : JSQualifiedName;
	static isImportantName(arg1 : string) : boolean;
	static replaceExpression(arg1 : JSNamespaceEvaluationResult, arg2 : JSQualifiedName, arg3 : JSQualifiedName) : JSNamespaceEvaluationResult;
	static findQualifyingExpressionFromArgumentList(arg1 : JSArgumentList) : JSElement;
	static isFrameworkMethod(arg1 : string) : boolean;
	static getFirstLiteralOrExprArg(arg1 : JSArgumentList) : JSElement;
	static isExtendCall(arg1 : JSExpression, arg2 : string) : boolean;
	static getAnonymousFunCall(arg1 : JSFunction) : JSCallExpression;
	static getParameterInitializationIfRequireArgument(arg1 : JSParameter) : JSLiteralExpression;
	static getParameterInitialization(arg1 : JSParameter) : JSExpression;
	static escapeKeyword(arg1 : string, arg2 : PsiElement) : string;
	static calcPackage(arg1 : PsiFile) : string;
	static getRequireArguments(arg1 : JSFunction) : Pair<JSExpression, JSExpression>;
	static isExportReference(arg1 : JSReferenceExpression) : boolean;
	static isExplicitExportReference(arg1 : JSExpression) : boolean;
	static evaluateModuleInnerAlias(arg1 : JSFunction, arg2 : string) : JSType;
	static getContext(arg1 : JSElement) : JSContext;
	static isInInterface(arg1 : TypeScriptTypeMember) : boolean;
	static getIndexedPropertyName(arg1 : JSIndexedPropertyAccessExpression) : string;
	static findNamespace(arg1 : JSExpression) : JSSymbolNamespace;
	static isValidPropertyName(arg1 : string) : boolean;
}


declare module JSSymbolUtil {
	class PropertyProcessor extends Object {
		process(arg1 : string, arg2 : JSProperty) : void;
	}
	class ReferenceExpressionProcessor extends Object {
		processExpression(arg1 : JSReferenceExpression) : void;
		processUnresolvedThis() : void;
		isTopLevel(arg1 : JSReferenceExpression) : boolean;
	}
}

export = JSSymbolUtil
