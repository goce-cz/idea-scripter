import JavaScriptParser = require('nashorn/com/intellij/lang/javascript/parsing/JavaScriptParser');
import IElementType = require('nashorn/com/intellij/psi/tree/IElementType');
import PsiBuilder = require('nashorn/com/intellij/lang/PsiBuilder');
import JavaScriptParserBase = require('nashorn/com/intellij/lang/javascript/parsing/JavaScriptParserBase');
import Enum = require('nashorn/java/lang/Enum');

declare class StatementParser<T extends JavaScriptParser> {
	variableElementType : IElementType;
	parseSourceElement() : void;
	parsePackageBodyStatement() : void;
	parsePackage() : void;
	parseStatement() : void;
	doParseStatement(arg1 : boolean) : void;
	isModifier(arg1 : IElementType) : boolean;
	hasAttributeModifiers() : boolean;
	parseDialectSpecificSourceElements(arg1 : PsiBuilder.Marker) : boolean;
	parseClassNoMarker(arg1 : PsiBuilder.Marker) : void;
	getClassElementType() : IElementType;
	parseClassMember() : void;
	startAttributeListOwner() : PsiBuilder.Marker;
	parseExpressionStatement() : boolean;
	parseLetBlock() : void;
	parseLetDeclarations() : boolean;
	parseDefaultNsStatement() : void;
	parseNamespaceNoMarker(arg1 : PsiBuilder.Marker) : boolean;
	parseIncludeDirective() : void;
	parseUseNamespaceDirective() : void;
	parseImportStatement() : void;
	parseClassOrInterfaceNoMarker(arg1 : PsiBuilder.Marker) : void;
	parseInterfaceNoMarker(arg1 : PsiBuilder.Marker) : void;
	parseReferenceList() : void;
	parseTryStatement() : void;
	parseCatchBlock() : void;
	parseThrowStatement() : void;
	parseSwitchStatement() : void;
	parseCaseOrDefaultClause() : void;
	parseWithStatement() : void;
	parseReturnStatement() : void;
	parseBreakStatement() : void;
	parseContinueStatement() : void;
	parseIterationStatement() : void;
	parseForStatement() : void;
	parseForLoopHeader() : boolean;
	parseWhileStatement() : void;
	parseDoWhileStatement() : void;
	parseIfStatement() : void;
	parseIfStatementHeader() : void;
	parseEmptyStatement() : void;
	parseVarStatement(arg1 : boolean) : void;
	parseVarStatementNoMarker(arg1 : boolean, arg2 : PsiBuilder.Marker) : void;
	parseVarList(arg1 : boolean) : void;
	checkForSemicolon() : boolean;
	forceCheckForSemicolon() : void;
	parseVarDeclaration(arg1 : boolean) : void;
	getVariableElementType() : IElementType;
	parseVarName(arg1 : PsiBuilder.Marker) : boolean;
	isLocalVarContext() : boolean;
	parseVariableInitializer(arg1 : boolean) : void;
	parseBlock() : void;
	parseFunctionBody() : boolean;
	checkIdentifier(arg1 : IElementType) : boolean;
	parseES6FromDeclaration() : void;
	parseES6ImportStatement() : void;
	parseES6ImportClause() : boolean;
	parseES6NamespaceImport() : void;
	parseES6ImportOrExportClause(arg1 : boolean) : void;
	parseES6ImportOrExportSpecifier(arg1 : boolean) : boolean;
	parseBlockOrFunctionBody(arg1 : StatementParser.BlockType) : boolean;
	parseBlockNoMarker(arg1 : StatementParser.BlockType, arg2 : PsiBuilder.Marker) : boolean;
}


declare interface StatementParser<T extends JavaScriptParser> extends JavaScriptParserBase<T> {}

declare module StatementParser {
	class BlockType {
		static FUNCTION_BODY : StatementParser.BlockType;
		static ARROW_FUNCTION_BODY : StatementParser.BlockType;
		static BLOCK : StatementParser.BlockType;
		static PACKAGE_OR_CLASS_BODY : StatementParser.BlockType;
	}


	interface BlockType extends Enum<StatementParser.BlockType> {}}

export = StatementParser
