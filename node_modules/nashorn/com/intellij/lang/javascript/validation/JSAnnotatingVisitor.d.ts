import PsiElement = require('nashorn/com/intellij/psi/PsiElement');
import JSHighlighter = require('nashorn/com/intellij/lang/javascript/highlighting/JSHighlighter');
import Project = require('nashorn/com/intellij/openapi/project/Project');
import JSReferenceExpression = require('nashorn/com/intellij/lang/javascript/psi/JSReferenceExpression');
import ProblemHighlightType = require('nashorn/com/intellij/codeInspection/ProblemHighlightType');
import PsiReference = require('nashorn/com/intellij/psi/PsiReference');
import TextRange = require('nashorn/com/intellij/openapi/util/TextRange');
import JSCallExpression = require('nashorn/com/intellij/lang/javascript/psi/JSCallExpression');
import JSType = require('nashorn/com/intellij/lang/javascript/psi/JSType');
import JSExpression = require('nashorn/com/intellij/lang/javascript/psi/JSExpression');
import ResolveResult = require('nashorn/com/intellij/psi/ResolveResult');
import List = require('nashorn/java/util/List');
import LocalQuickFix = require('nashorn/com/intellij/codeInspection/LocalQuickFix');
import JSArgumentList = require('nashorn/com/intellij/lang/javascript/psi/JSArgumentList');
import JSAnnotateHighlighterFilter = require('nashorn/com/intellij/lang/javascript/highlighting/JSAnnotateHighlighterFilter');
import JSLanguageFeature = require('nashorn/com/intellij/lang/javascript/dialects/JSLanguageFeature');
import ASTNode = require('nashorn/com/intellij/lang/ASTNode');
import JSFunction = require('nashorn/com/intellij/lang/javascript/psi/JSFunction');
import JSParameter = require('nashorn/com/intellij/lang/javascript/psi/JSParameter');
import JSClass = require('nashorn/com/intellij/lang/javascript/psi/ecmal4/JSClass');
import JSAttributeList = require('nashorn/com/intellij/lang/javascript/psi/ecmal4/JSAttributeList');
import JSResolveResult = require('nashorn/com/intellij/lang/javascript/psi/resolve/JSResolveResult');
import JSBlockStatement = require('nashorn/com/intellij/lang/javascript/psi/JSBlockStatement');
import IElementType = require('nashorn/com/intellij/psi/tree/IElementType');
import Pair = require('nashorn/com/intellij/openapi/util/Pair');
import JSVariable = require('nashorn/com/intellij/lang/javascript/psi/JSVariable');
import JSElementVisitor = require('nashorn/com/intellij/lang/javascript/psi/JSElementVisitor');
import Annotator = require('nashorn/com/intellij/lang/annotation/Annotator');
import Enum = require('nashorn/java/lang/Enum');
import Object = require('nashorn/java/lang/Object');
import IntentionAction = require('nashorn/com/intellij/codeInsight/intention/IntentionAction');

declare class JSAnnotatingVisitor {
	static VOID_TYPE_NAME : string;
	constructor();
	getHighlighter(arg1 : PsiElement) : JSHighlighter;
	initTypeCheckers(arg1 : Project) : void;
	getUnresolvedReferenceHighlightType(arg1 : JSReferenceExpression) : ProblemHighlightType;
	getHighlightTypeForTypeOrSignatureProblem(arg1 : PsiElement) : ProblemHighlightType;
	checkReferences(arg1 : PsiElement) : boolean;
	static calcRangeForReferences(arg1 : PsiReference) : TextRange;
	static hasBadResolve(arg1 : PsiReference) : boolean;
	processMethodExpressionResolveResult(arg1 : JSCallExpression, arg2 : JSReferenceExpression, arg3 : PsiElement, arg4 : JSType) : boolean;
	checkNewExpressionInsideCallReferences(arg1 : JSExpression) : void;
	checkCallReferences(arg1 : JSCallExpression, arg2 : JSReferenceExpression) : void;
	addCreateFromUsageFixesForCall(arg1 : JSCallExpression, arg2 : JSReferenceExpression, arg3 : ResolveResult[], arg4 : List<LocalQuickFix>) : void;
	createClassOrInterfaceFix(arg1 : JSReferenceExpression, arg2 : boolean, arg3 : JSArgumentList, arg4 : JSType) : LocalQuickFix;
	renameReferenceFix() : LocalQuickFix;
	reportUnresolvedRefProblem(arg1 : ProblemHighlightType, arg2 : List<LocalQuickFix>, arg3 : PsiElement, arg4 : string, arg5 : string) : void;
	getAnnotateHighlighterFilter(arg1 : PsiElement) : JSAnnotateHighlighterFilter;
	checkElementInCurrentLanguageLevel(arg1 : PsiElement, arg2 : JSLanguageFeature) : void;
	checkSetterReturnType(arg1 : ASTNode, arg2 : JSFunction) : void;
	checkGetterAndSetterTypeMatch(arg1 : JSFunction, arg2 : JSFunction, arg3 : JSParameter, arg4 : JSType, arg5 : JSType) : void;
	validateGetPropertyReturnType(arg1 : ASTNode, arg2 : JSFunction, arg3 : JSType) : void;
	static isEvalAllowed(arg1 : JSReferenceExpression) : boolean;
	static isBindable(arg1 : JSClass) : boolean;
	checkAccessorAccessTypeMatch(arg1 : JSFunction, arg2 : JSFunction, arg3 : string) : void;
	static differentAccessType(arg1 : JSAttributeList, arg2 : JSAttributeList) : boolean;
	checkRefExpression(arg1 : JSReferenceExpression) : void;
	registerQuickFixesForUnresolvedRef(arg1 : JSReferenceExpression, arg2 : ResolveResult[]) : void;
	addCreateFromUsageFixes(arg1 : JSReferenceExpression, arg2 : ResolveResult[], arg3 : List<LocalQuickFix>, arg4 : boolean, arg5 : boolean) : boolean;
	createJSVariableIntentionAction(arg1 : string, arg2 : boolean, arg3 : boolean) : LocalQuickFix;
	suggestCreateVarFromUsage(arg1 : JSReferenceExpression) : boolean;
	getPreferredQuickFixForUnresolvedRef(arg1 : PsiElement) : LocalQuickFix;
	static findInsufficientVisibilityResult(arg1 : ResolveResult[]) : JSResolveResult;
	static addEscalateVisibilityFix(arg1 : ResolveResult[], arg2 : JSReferenceExpression, arg3 : List<LocalQuickFix>) : void;
	static canHaveCreateFromUsage(arg1 : JSExpression) : boolean;
	static addCreateParameterFix(arg1 : PsiElement, arg2 : List<LocalQuickFix>, arg3 : string) : void;
	checkMissedSuperCall(arg1 : JSReferenceExpression, arg2 : JSFunction, arg3 : JSClass) : void;
	static hasSuperConstructorCall(arg1 : JSFunction) : boolean;
	static containsSuperCall(arg1 : JSBlockStatement) : boolean;
	static getNontrivialSuperClassConstructor(arg1 : JSClass) : JSFunction;
	needsInitializer(arg1 : JSParameter) : boolean;
	validateRestParameterType(arg1 : JSParameter) : void;
	static getNodesBefore(arg1 : PsiElement, arg2 : IElementType) : Pair<ASTNode, ASTNode>;
	checkLhs(arg1 : JSExpression) : void;
	checkAssignmentToConst(arg1 : JSReferenceExpression) : boolean;
	checkTypesInVariable(arg1 : JSVariable) : void;
	checkFunction(arg1 : JSFunction) : void;
	static compatibleType(arg1 : string, arg2 : string, arg3 : PsiElement, arg4 : PsiElement) : boolean;
}


declare interface JSAnnotatingVisitor extends JSElementVisitor, Annotator {}

declare module JSAnnotatingVisitor {
	class SimpleErrorReportingClient {
		constructor();
	}


	interface SimpleErrorReportingClient extends JSAnnotatingVisitor.ErrorReportingClient {}	class SignatureMatchResult {
		static PARAMETERS_DIFFERS : JSAnnotatingVisitor.SignatureMatchResult;
		static RETURN_TYPE_DIFFERS : JSAnnotatingVisitor.SignatureMatchResult;
		static FUNCTION_KIND_DIFFERS : JSAnnotatingVisitor.SignatureMatchResult;
		static COMPATIBLE_SIGNATURE : JSAnnotatingVisitor.SignatureMatchResult;
	}


	interface SignatureMatchResult extends Enum<JSAnnotatingVisitor.SignatureMatchResult> {}	class ErrorReportingClient extends Object {
		reportError(arg1 : ASTNode, arg2 : string, arg3 : JSAnnotatingVisitor.ErrorReportingClient.ProblemKind, arg4 : IntentionAction[]) : void;
	}


	module ErrorReportingClient {
		class ProblemKind {
			static ERROR : JSAnnotatingVisitor.ErrorReportingClient.ProblemKind;
			static WARNING : JSAnnotatingVisitor.ErrorReportingClient.ProblemKind;
		}


		interface ProblemKind extends Enum<JSAnnotatingVisitor.ErrorReportingClient.ProblemKind> {}	}
	class ProblemKindHolder extends Object {
		problemKind : JSAnnotatingVisitor.ProblemKind;
		getProblemKind() : JSAnnotatingVisitor.ProblemKind;
	}
	class ProblemKind {
		static ERROR : JSAnnotatingVisitor.ProblemKind;
		static WARNING : JSAnnotatingVisitor.ProblemKind;
		static INFO : JSAnnotatingVisitor.ProblemKind;
	}


	interface ProblemKind extends Enum<JSAnnotatingVisitor.ProblemKind> {}}

export = JSAnnotatingVisitor
