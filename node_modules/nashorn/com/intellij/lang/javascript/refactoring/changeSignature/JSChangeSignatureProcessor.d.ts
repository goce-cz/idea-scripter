import JSFunction = require('nashorn/com/intellij/lang/javascript/psi/JSFunction');
import JSAttributeList = require('nashorn/com/intellij/lang/javascript/psi/ecmal4/JSAttributeList');
import JSParameterInfo = require('nashorn/com/intellij/lang/javascript/refactoring/changeSignature/JSParameterInfo');
import Set = require('nashorn/java/util/Set');
import Condition = require('nashorn/com/intellij/openapi/util/Condition');
import Collection = require('nashorn/java/util/Collection');
import UsageInfo = require('nashorn/com/intellij/usageView/UsageInfo');
import JSParameter = require('nashorn/com/intellij/lang/javascript/psi/JSParameter');
import MultiMap = require('nashorn/com/intellij/util/containers/MultiMap');
import PsiFile = require('nashorn/com/intellij/psi/PsiFile');
import JSCallExpression = require('nashorn/com/intellij/lang/javascript/psi/JSCallExpression');
import PsiElement = require('nashorn/com/intellij/psi/PsiElement');
import JSArgumentList = require('nashorn/com/intellij/lang/javascript/psi/JSArgumentList');
import JSVariable = require('nashorn/com/intellij/lang/javascript/psi/JSVariable');
import JSParameterList = require('nashorn/com/intellij/lang/javascript/psi/JSParameterList');
import JSLanguageDialect = require('nashorn/com/intellij/lang/javascript/JSLanguageDialect');
import BaseRefactoringProcessor = require('nashorn/com/intellij/refactoring/BaseRefactoringProcessor');
import JSElement = require('nashorn/com/intellij/lang/javascript/psi/JSElement');

declare class JSChangeSignatureProcessor {
	constructor(arg1 : JSFunction, arg2 : JSAttributeList.AccessType, arg3 : string, arg4 : string, arg5 : JSParameterInfo[], arg6 : Set<JSFunction>);
	setDeclarationsFilter(arg1 : Condition<JSFunction>) : void;
	findPropagationUsages(arg1 : Collection<UsageInfo>, arg2 : Collection<JSChangeSignatureProcessor.OtherUsageInfo>) : void;
	static rename(arg1 : JSParameter, arg2 : string, arg3 : MultiMap<JSParameter, UsageInfo>) : void;
	refactorDeclarationOrUsage(arg1 : UsageInfo, arg2 : Collection<PsiFile>) : void;
	refactorCall(arg1 : JSCallExpression, arg2 : JSParameterInfo[], arg3 : boolean, arg4 : number, arg5 : number, arg6 : Collection<PsiFile>) : void;
	static computeRequiredImportStatements(arg1 : string, arg2 : PsiElement, arg3 : Collection<string>) : void;
	static getEscaped(arg1 : string, arg2 : PsiElement) : string;
	static needsApos(arg1 : PsiElement) : boolean;
	static addCommaIfNeeded(arg1 : JSArgumentList) : void;
	refactorMethodDeclaration(arg1 : JSFunction, arg2 : Collection<PsiFile>, arg3 : MultiMap<JSParameter, UsageInfo>) : void;
	refactorFieldDeclaration(arg1 : JSVariable, arg2 : Collection<PsiFile>) : void;
	setParameters(arg1 : JSFunction, arg2 : MultiMap<JSParameter, UsageInfo>, arg3 : Collection<PsiFile>, arg4 : JSParameterInfo[]) : void;
	static addParenthesisIfNeeded(arg1 : JSParameterList) : JSParameterList;
	static removeParenthesis(arg1 : JSParameterList) : JSParameterList;
	static addComma(arg1 : PsiElement) : void;
	static getNumberOfParams(arg1 : JSFunction) : number;
	static checkLocalCollisions(arg1 : JSFunction, arg2 : JSParameterInfo[], arg3 : MultiMap<PsiElement, string>) : void;
	static getCollidingElement(arg1 : JSFunction, arg2 : string, arg3 : Condition<PsiElement>) : PsiElement;
	static reportLocalCollisions(arg1 : JSFunction, arg2 : string, arg3 : boolean, arg4 : MultiMap<PsiElement, string>, arg5 : Condition<PsiElement>) : void;
	shouldPropagate(arg1 : PsiElement) : boolean;
	getLangForProcessing() : JSLanguageDialect;
}


declare interface JSChangeSignatureProcessor extends BaseRefactoringProcessor {}

declare module JSChangeSignatureProcessor {
	class OtherUsageInfo {
		rebindTo : JSElement;
		parameters : JSParameterInfo[];
		propagate : boolean;
		constructor(arg1 : PsiElement, arg2 : JSElement, arg3 : JSParameterInfo[], arg4 : boolean, arg5 : number, arg6 : number);
		getRebindTo() : JSElement;
		getParameters() : JSParameterInfo[];
		isPropagate() : boolean;
	}


	interface OtherUsageInfo extends UsageInfo {}	class FieldDeclarationUsageInfo {
		element : JSVariable;
		constructor(arg1 : JSVariable);
	}


	interface FieldDeclarationUsageInfo extends UsageInfo {}	class FunctionExpressionDeclarationUsageInfo {
		constructor(arg1 : PsiElement, arg2 : JSParameterInfo[]);
	}


	interface FunctionExpressionDeclarationUsageInfo extends JSChangeSignatureProcessor.FunctionDeclarationUsageInfoBase {}	class MethodDeclarationUsageInfo {
		element : JSFunction;
		constructor(arg1 : JSFunction, arg2 : JSParameterInfo[]);
	}


	interface MethodDeclarationUsageInfo extends JSChangeSignatureProcessor.FunctionDeclarationUsageInfoBase {}	class FunctionDeclarationUsageInfoBase {
		paramsOverride : JSParameterInfo[];
		paramsUsages : MultiMap<JSParameter, UsageInfo>;
		getFunction() : JSFunction;
		getParamsOverride() : JSParameterInfo[];
		getParamsUsages() : MultiMap<JSParameter, UsageInfo>;
		searchForParametersUsages() : void;
	}


	interface FunctionDeclarationUsageInfoBase extends UsageInfo {}}

export = JSChangeSignatureProcessor
