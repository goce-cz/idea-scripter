import JSElement = require('nashorn/com/intellij/lang/javascript/psi/JSElement');
import BaseIntroduceSettings = require('nashorn/com/intellij/lang/javascript/refactoring/introduce/BaseIntroduceSettings');
import JSBaseIntroduceDialog = require('nashorn/com/intellij/lang/javascript/refactoring/introduce/JSBaseIntroduceDialog');
import PsiFile = require('nashorn/com/intellij/psi/PsiFile');
import List = require('nashorn/java/util/List');
import Pair = require('nashorn/com/intellij/openapi/util/Pair');
import JSExpression = require('nashorn/com/intellij/lang/javascript/psi/JSExpression');
import TextRange = require('nashorn/com/intellij/openapi/util/TextRange');
import PsiElement = require('nashorn/com/intellij/psi/PsiElement');
import JSReferenceExpression = require('nashorn/com/intellij/lang/javascript/psi/JSReferenceExpression');
import Editor = require('nashorn/com/intellij/openapi/editor/Editor');
import Map = require('nashorn/java/util/Map');
import OccurrencesChooser = require('nashorn/com/intellij/refactoring/introduce/inplace/OccurrencesChooser');
import Pass = require('nashorn/com/intellij/openapi/util/Pass');
import Project = require('nashorn/com/intellij/openapi/project/Project');
import JSBaseInplaceIntroducer = require('nashorn/com/intellij/lang/javascript/refactoring/introduce/JSBaseInplaceIntroducer');
import ClassLevelIntroduceSettings = require('nashorn/com/intellij/lang/javascript/refactoring/introduce/ClassLevelIntroduceSettings');
import DataContext = require('nashorn/com/intellij/openapi/actionSystem/DataContext');
import InplaceSettings = require('nashorn/com/intellij/lang/javascript/refactoring/introduceVariable/InplaceSettings');
import JSLanguageDialect = require('nashorn/com/intellij/lang/javascript/JSLanguageDialect');
import JSVarStatement = require('nashorn/com/intellij/lang/javascript/psi/JSVarStatement');
import JSStatement = require('nashorn/com/intellij/lang/javascript/psi/JSStatement');
import RefactoringActionHandler = require('nashorn/com/intellij/refactoring/RefactoringActionHandler');
import Object = require('nashorn/java/lang/Object');

declare class JSBaseIntroduceHandler<T extends JSElement, S extends BaseIntroduceSettings, D extends JSBaseIntroduceDialog> {
	static SYNC_TEST_CHOOSER : string;
	constructor();
	static findExpressionsInRange(arg1 : PsiFile, arg2 : number, arg3 : number) : List<Pair<JSExpression, TextRange>>;
	static adjustElement(arg1 : number, arg2 : PsiElement) : PsiElement;
	static isValidExpressionForSmartIntroduce(arg1 : PsiElement) : boolean;
	static isValidExpression(arg1 : PsiElement) : boolean;
	static isInvalidRefExpr(arg1 : JSReferenceExpression) : boolean;
	static ensureNoIntersection(arg1 : TextRange, arg2 : PsiElement, arg3 : JSExpression) : PsiElement;
	static elementNotAllowedInRange(arg1 : TextRange, arg2 : PsiElement) : boolean;
	visitInnerFunctions() : boolean;
	chooseOccurrencesToReplace(arg1 : Editor, arg2 : Map<OccurrencesChooser.ReplaceChoice, List<JSExpression>>, arg3 : Pass<OccurrencesChooser.ReplaceChoice>) : void;
	createInplaceIntroducer(arg1 : JSBaseIntroduceHandler.BaseIntroduceContext<S>, arg2 : JSElement, arg3 : Editor, arg4 : Project, arg5 : JSExpression[]) : JSBaseInplaceIntroducer<S>;
	doPreprocess(arg1 : Project, arg2 : S) : void;
	getProductivityFeatureId() : string;
	static prependAccessModifier(arg1 : JSBaseIntroduceHandler.BaseIntroduceContext<ClassLevelIntroduceSettings>, arg2 : string) : string;
	static introduceOverVariableNameRef(arg1 : PsiElement) : boolean;
	static calcDependsOnContext(arg1 : PsiElement, arg2 : boolean, arg3 : boolean) : boolean;
	findIntroducedScope(arg1 : JSExpression, arg2 : DataContext) : JSElement;
	getRefactoringName() : string;
	getCannotIntroduceMessagePropertyKey() : string;
	getCannotIntroduceVoidExpressionTypeMessagePropertyKey() : string;
	static isIntroducingPartOfExpression(arg1 : Pair<JSExpression, TextRange>) : boolean;
	findIntroducedExpression(arg1 : PsiFile, arg2 : number, arg3 : number, arg4 : Editor, arg5 : DataContext) : Pair<JSExpression, TextRange>;
	getInplaceSettings(arg1 : Pair<JSExpression, TextRange>, arg2 : JSExpression[], arg3 : PsiElement, arg4 : OccurrencesChooser.ReplaceChoice) : InplaceSettings<S>;
	getSettings(arg1 : Project, arg2 : Editor, arg3 : Pair<JSExpression, TextRange>, arg4 : JSExpression[], arg5 : PsiElement) : S;
	createSettings(arg1 : D) : S;
	createDialog(arg1 : Project, arg2 : JSExpression, arg3 : JSExpression[], arg4 : PsiElement) : D;
	doRefactoring(arg1 : Project, arg2 : Editor, arg3 : JSBaseIntroduceHandler.BaseIntroduceContext<S>, arg4 : boolean) : JSBaseIntroduceHandler.IntroduceInfo<T>;
	createRefExpr(arg1 : Project, arg2 : S, arg3 : JSLanguageDialect) : JSExpression;
	static fixFormat(arg1 : Project, arg2 : PsiElement) : void;
	doPostprocess(arg1 : JSVarStatement, arg2 : S, arg3 : boolean) : void;
	doPostprocess(arg1 : JSVarStatement, arg2 : S, arg3 : boolean, arg4 : Editor) : void;
	prepareDeclaration(arg1 : string, arg2 : JSBaseIntroduceHandler.BaseIntroduceContext<S>, arg3 : Project, arg4 : JSLanguageDialect, arg5 : T, arg6 : Editor, arg7 : JSExpression) : Pair<JSVarStatement, boolean>;
	getReplacementExpression(arg1 : Pair<JSExpression, TextRange>) : JSExpression;
	getIntroducedExpressionText(arg1 : Pair<JSExpression, TextRange>) : string;
	getDeclText(arg1 : JSBaseIntroduceHandler.BaseIntroduceContext<S>, arg2 : T) : string;
	calcDeclText(arg1 : JSBaseIntroduceHandler.BaseIntroduceContext<S>, arg2 : string, arg3 : T) : string;
	addStatementBefore(arg1 : T, arg2 : JSVarStatement) : T;
	findAnchor(arg1 : JSBaseIntroduceHandler.BaseIntroduceContext<S>, arg2 : boolean) : T;
	static getAnchorToInsert(arg1 : JSExpression[]) : JSStatement;
	static findClassAnchor(arg1 : PsiElement) : JSElement;
	static addToClassAnchor(arg1 : JSElement, arg2 : JSVarStatement) : JSElement;
}


declare interface JSBaseIntroduceHandler<T extends JSElement, S extends BaseIntroduceSettings, D extends JSBaseIntroduceDialog> extends RefactoringActionHandler {}

declare module JSBaseIntroduceHandler {
	class Replacer extends Object {
		myExpressionDescriptor : Pair<JSExpression, TextRange>;
		introducedExpressionText : string;
		constructor(arg1 : Pair<JSExpression, TextRange>);
		static findTopXmlLiteralExpression(arg1 : JSExpression) : JSExpression;
		replaceExpr(arg1 : JSExpression, arg2 : JSExpression) : JSExpression;
		buildTextForReplacement(arg1 : JSExpression, arg2 : string, arg3 : string) : JSExpression;
		getIntroducedExpressionText() : string;
	}
	class IntroduceInfo<T extends JSElement> extends Object {
		constructor();
	}
	class BaseIntroduceContext<S extends BaseIntroduceSettings> extends Object {
		settings : S;
		expressionDescriptor : Pair<JSExpression, TextRange>;
		constructor(arg1 : Pair<JSExpression, TextRange>, arg2 : JSExpression[], arg3 : PsiElement, arg4 : S);
	}
}

export = JSBaseIntroduceHandler
