import ASTNode = require('nashorn/com/intellij/lang/ASTNode');
import WrapType = require('nashorn/com/intellij/formatting/WrapType');
import Alignment = require('nashorn/com/intellij/formatting/Alignment');
import XmlTag = require('nashorn/com/intellij/psi/xml/XmlTag');
import Wrap = require('nashorn/com/intellij/formatting/Wrap');
import List = require('nashorn/java/util/List');
import Block = require('nashorn/com/intellij/formatting/Block');
import Indent = require('nashorn/com/intellij/formatting/Indent');
import PsiElement = require('nashorn/com/intellij/psi/PsiElement');
import XmlElement = require('nashorn/com/intellij/psi/xml/XmlElement');
import XmlBlock = require('nashorn/com/intellij/psi/formatter/xml/XmlBlock');
import XmlTagBlock = require('nashorn/com/intellij/psi/formatter/xml/XmlTagBlock');
import XmlFormattingPolicy = require('nashorn/com/intellij/psi/formatter/xml/XmlFormattingPolicy');
import Language = require('nashorn/com/intellij/lang/Language');
import Spacing = require('nashorn/com/intellij/formatting/Spacing');
import AbstractBlock = require('nashorn/com/intellij/psi/formatter/common/AbstractBlock');

declare class AbstractXmlBlock {
	preserveSpace : boolean;
	textElement : boolean;
	leaf : boolean;
	cDATAStart : boolean;
	cDATAEnd : boolean;
	static a(arg1 : ASTNode, arg2 : boolean) : boolean;
	isPreserveSpace() : boolean;
	static getWrapType(arg1 : number) : WrapType;
	chooseAlignment(arg1 : ASTNode, arg2 : Alignment, arg3 : Alignment) : Alignment;
	a(arg1 : XmlTag) : Wrap;
	chooseWrap(arg1 : ASTNode, arg2 : Wrap, arg3 : Wrap, arg4 : Wrap) : Wrap;
	canWrapTagEnd(arg1 : XmlTag) : boolean;
	getTag() : XmlTag;
	static getTag(arg1 : ASTNode) : XmlTag;
	createTagBeginWrapping(arg1 : XmlTag) : Wrap;
	processChild(arg1 : List<Block>, arg2 : ASTNode, arg3 : Wrap, arg4 : Alignment, arg5 : Indent) : ASTNode;
	doesNotIntersectSubTagsWith(arg1 : PsiElement) : boolean;
	c() : XmlTag[];
	static a(arg1 : XmlElement) : XmlTag[];
	containsTag(arg1 : PsiElement) : boolean;
	a(arg1 : List<Block>, arg2 : ASTNode, arg3 : Wrap, arg4 : Alignment, arg5 : Indent) : ASTNode;
	processSimpleChild(arg1 : ASTNode, arg2 : Indent, arg3 : List<Block>, arg4 : Wrap, arg5 : Alignment) : void;
	createSimpleChild(arg1 : ASTNode, arg2 : Indent, arg3 : Wrap, arg4 : Alignment) : XmlBlock;
	createTagBlock(arg1 : ASTNode, arg2 : Indent, arg3 : Wrap, arg4 : Alignment) : XmlTagBlock;
	findXmlTagAt(arg1 : ASTNode, arg2 : number) : XmlTag;
	createAnotherTreeNode(arg1 : List<Block>, arg2 : ASTNode, arg3 : PsiElement, arg4 : Indent, arg5 : Wrap, arg6 : Alignment) : ASTNode;
	createAnotherTreeTagBlock(arg1 : PsiElement, arg2 : Indent) : Block;
	createPolicyFor() : XmlFormattingPolicy;
	getAnotherTreeTag(arg1 : ASTNode) : XmlTag;
	isXmlTag(arg1 : ASTNode) : boolean;
	isXmlTag(arg1 : PsiElement) : boolean;
	useMyFormatter(arg1 : Language, arg2 : Language, arg3 : PsiElement) : boolean;
	isJspxJavaContainingNode(arg1 : ASTNode) : boolean;
	insertLineBreakBeforeTag() : boolean;
	removeLineBreakBeforeTag() : boolean;
	createDefaultSpace(arg1 : boolean, arg2 : boolean) : Spacing;
	a(arg1 : boolean, arg2 : boolean) : boolean;
	isTextElement() : boolean;
	createJspTextNode(arg1 : List<Block>, arg2 : ASTNode, arg3 : Indent) : void;
	static findChildAfter(arg1 : ASTNode, arg2 : number) : ASTNode;
	static a(arg1 : ASTNode) : boolean;
	setXmlFormattingPolicy(arg1 : XmlFormattingPolicy) : void;
	buildInjectedPsiBlocks(arg1 : List<Block>, arg2 : ASTNode, arg3 : Wrap, arg4 : Alignment, arg5 : Indent) : boolean;
	isCDATAStart() : boolean;
	isCDATAEnd() : boolean;
	static containsWhiteSpacesOnly(arg1 : ASTNode) : boolean;
	static b(arg1 : ASTNode) : boolean;
}


declare interface AbstractXmlBlock extends AbstractBlock {}
export = AbstractXmlBlock
