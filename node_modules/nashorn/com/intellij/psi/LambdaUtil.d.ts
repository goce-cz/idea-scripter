import Object = require('nashorn/java/lang/Object');
import ThreadLocal = require('nashorn/java/lang/ThreadLocal');
import Map = require('nashorn/java/util/Map');
import PsiElement = require('nashorn/com/intellij/psi/PsiElement');
import PsiType = require('nashorn/com/intellij/psi/PsiType');
import PsiFunctionalExpression = require('nashorn/com/intellij/psi/PsiFunctionalExpression');
import PsiMethod = require('nashorn/com/intellij/psi/PsiMethod');
import PsiClassType = require('nashorn/com/intellij/psi/PsiClassType');
import PsiClass = require('nashorn/com/intellij/psi/PsiClass');
import PsiSubstitutor = require('nashorn/com/intellij/psi/PsiSubstitutor');
import PsiLambdaExpression = require('nashorn/com/intellij/psi/PsiLambdaExpression');
import MethodSignature = require('nashorn/com/intellij/psi/util/MethodSignature');
import HierarchicalMethodSignature = require('nashorn/com/intellij/psi/HierarchicalMethodSignature');
import List = require('nashorn/java/util/List');
import PsiExpressionList = require('nashorn/com/intellij/psi/PsiExpressionList');
import PsiTypeParameter = require('nashorn/com/intellij/psi/PsiTypeParameter');
import PsiIntersectionType = require('nashorn/com/intellij/psi/PsiIntersectionType');
import PsiParameter = require('nashorn/com/intellij/psi/PsiParameter');
import PsiReturnStatement = require('nashorn/com/intellij/psi/PsiReturnStatement');
import PsiExpression = require('nashorn/com/intellij/psi/PsiExpression');
import PsiReferenceExpression = require('nashorn/com/intellij/psi/PsiReferenceExpression');
import LanguageLevel = require('nashorn/com/intellij/pom/java/LanguageLevel');
import Set = require('nashorn/java/util/Set');
import PsiTypeVisitor = require('nashorn/com/intellij/psi/PsiTypeVisitor');

declare class LambdaUtil extends Object {
	static ourFunctionTypes : ThreadLocal<Map<PsiElement, PsiType>>;
	static functionalTypeMap : Map<PsiElement, PsiType>;
	constructor();
	static getFunctionalInterfaceReturnType(arg1 : PsiFunctionalExpression) : PsiType;
	static getFunctionalInterfaceReturnType(arg1 : PsiType) : PsiType;
	static getFunctionalInterfaceMethod(arg1 : PsiType) : PsiMethod;
	static getFunctionalInterfaceMethod(arg1 : PsiElement) : PsiMethod;
	static getFunctionalInterfaceMethod(arg1 : PsiClassType.ClassResolveResult) : PsiMethod;
	static getFunctionalInterfaceMethod(arg1 : PsiClass) : PsiMethod;
	static getSubstitutor(arg1 : PsiMethod, arg2 : PsiClassType.ClassResolveResult) : PsiSubstitutor;
	static isFunctionalType(arg1 : PsiType) : boolean;
	static isFunctionalClass(arg1 : PsiClass) : boolean;
	static isValidLambdaContext(arg1 : PsiElement) : boolean;
	static isLambdaFullyInferred(arg1 : PsiLambdaExpression, arg2 : PsiType) : boolean;
	static getFunction(arg1 : PsiClass) : MethodSignature;
	static overridesPublicObjectMethod(arg1 : HierarchicalMethodSignature) : boolean;
	static getMethodSignature(arg1 : PsiMethod, arg2 : PsiClass, arg3 : PsiClass) : MethodSignature;
	static hasSubsignature(arg1 : List<HierarchicalMethodSignature>) : List<HierarchicalMethodSignature>;
	static skipMethod(arg1 : HierarchicalMethodSignature, arg2 : HierarchicalMethodSignature) : boolean;
	static findFunctionCandidates(arg1 : PsiClass) : List<HierarchicalMethodSignature>;
	static getReturnType(arg1 : PsiClass, arg2 : MethodSignature) : PsiType;
	static getMethod(arg1 : PsiClass, arg2 : MethodSignature) : PsiMethod;
	static getLambdaIdx(arg1 : PsiExpressionList, arg2 : PsiElement) : number;
	static dependsOnTypeParams(arg1 : PsiType, arg2 : PsiType, arg3 : PsiElement, arg4 : PsiTypeParameter[]) : boolean;
	static depends(arg1 : PsiType, arg2 : LambdaUtil.TypeParamsChecker, arg3 : PsiTypeParameter[]) : boolean;
	static getFunctionalInterfaceType(arg1 : PsiElement, arg2 : boolean) : PsiType;
	static extractFunctionalConjunct(arg1 : PsiIntersectionType) : PsiType;
	static getFunctionalInterfaceTypeByContainingLambda(arg1 : PsiLambdaExpression) : PsiType;
	static adjustLambdaIdx(arg1 : number, arg2 : PsiMethod, arg3 : PsiParameter[]) : number;
	static getNormalizedType(arg1 : PsiParameter) : PsiType;
	static notInferredType(arg1 : PsiType) : boolean;
	static getReturnStatements(arg1 : PsiLambdaExpression) : PsiReturnStatement[];
	static getReturnExpressions(arg1 : PsiLambdaExpression) : List<PsiExpression>;
	static isValidQualifier4InterfaceStaticMethodCall(arg1 : PsiMethod, arg2 : PsiReferenceExpression, arg3 : PsiElement, arg4 : LanguageLevel) : boolean;
	static getInvalidQualifier4StaticInterfaceMethodMessage(arg1 : PsiMethod, arg2 : PsiReferenceExpression, arg3 : PsiElement, arg4 : LanguageLevel) : string;
	static isExpressionStatementExpression(arg1 : PsiElement) : boolean;
	static extractSingleExpressionFromBody(arg1 : PsiElement) : PsiExpression;
	static isPotentiallyCompatibleWithTypeParameter(arg1 : PsiFunctionalExpression, arg2 : PsiExpressionList, arg3 : PsiMethod) : boolean;
	static getFunctionalTypeMap() : Map<PsiElement, PsiType>;
	static checkReturnTypeCompatible(arg1 : PsiLambdaExpression, arg2 : PsiType) : string;
}


declare module LambdaUtil {
	class TypeParamsChecker {
		myUsedTypeParams : Set<PsiTypeParameter>;
		constructor(arg1 : PsiElement, arg2 : PsiClass);
		startedInference() : boolean;
		check(arg1 : PsiTypeParameter) : boolean;
		used(arg1 : PsiTypeParameter[]) : boolean;
	}


	interface TypeParamsChecker extends PsiTypeVisitor<boolean> {}}

export = LambdaUtil
