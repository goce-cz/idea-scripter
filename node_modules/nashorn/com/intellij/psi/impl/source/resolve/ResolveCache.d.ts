import Object = require('nashorn/java/lang/Object');
import MessageBus = require('nashorn/com/intellij/util/messages/MessageBus');
import Project = require('nashorn/com/intellij/openapi/project/Project');
import ConcurrentMap = require('nashorn/java/util/concurrent/ConcurrentMap');
import PsiReference = require('nashorn/com/intellij/psi/PsiReference');
import PsiPolyVariantReference = require('nashorn/com/intellij/psi/PsiPolyVariantReference');
import ResolveResult = require('nashorn/com/intellij/psi/ResolveResult');
import PsiFile = require('nashorn/com/intellij/psi/PsiFile');
import ConcurrentWeakKeySoftValueHashMap = require('nashorn/com/intellij/util/containers/ConcurrentWeakKeySoftValueHashMap');
import PsiElement = require('nashorn/com/intellij/psi/PsiElement');

declare class ResolveCache extends Object {
	constructor(arg1 : MessageBus);
	static getInstance(arg1 : Project) : ResolveCache;
	static a<K, V>() : ConcurrentMap<K, V>;
	clearCache(arg1 : boolean) : void;
	a<TRef extends PsiReference, TResult>(arg1 : TRef, arg2 : ResolveCache.AbstractResolver<TRef, TResult>, arg3 : boolean, arg4 : boolean, arg5 : boolean, arg6 : boolean) : TResult;
	resolveWithCaching<T extends PsiPolyVariantReference>(arg1 : T, arg2 : ResolveCache.PolyVariantResolver<T>, arg3 : boolean, arg4 : boolean) : ResolveResult[];
	resolveWithCaching<T extends PsiPolyVariantReference>(arg1 : T, arg2 : ResolveCache.PolyVariantResolver<T>, arg3 : boolean, arg4 : boolean, arg5 : PsiFile) : ResolveResult[];
	resolveWithCaching<T extends PsiPolyVariantReference>(arg1 : T, arg2 : ResolveCache.PolyVariantContextResolver<T>, arg3 : boolean, arg4 : boolean, arg5 : PsiFile) : ResolveResult[];
	getCachedResults<T extends PsiPolyVariantReference>(arg1 : T, arg2 : boolean, arg3 : boolean, arg4 : boolean) : ResolveResult[];
	resolveWithCaching<TRef extends PsiReference, TResult>(arg1 : TRef, arg2 : ResolveCache.AbstractResolver<TRef, TResult>, arg3 : boolean, arg4 : boolean) : TResult;
	a<TRef extends PsiReference, TResult>(arg1 : number) : ConcurrentMap<TRef, TResult>;
	static a(arg1 : boolean, arg2 : boolean, arg3 : boolean) : number;
	a<TRef extends PsiReference, TResult>(arg1 : TRef, arg2 : ConcurrentMap<TRef, TResult>, arg3 : TResult) : void;
	static a<K, V>(arg1 : V) : ResolveCache.StrongValueReference<K, V>;
}


declare module ResolveCache {
	class StrongValueReference<K, V> {
		keyReference : ConcurrentWeakKeySoftValueHashMap.KeyReference<K, V>;
		constructor(arg1 : V);
	}


	interface StrongValueReference<K, V> extends ConcurrentWeakKeySoftValueHashMap.ValueReference<K, V> {}	class Resolver {
	}


	interface Resolver extends ResolveCache.AbstractResolver<PsiReference, PsiElement> {}	class PolyVariantContextResolver<T extends PsiPolyVariantReference> extends Object {
		resolve(arg1 : T, arg2 : PsiFile, arg3 : boolean) : ResolveResult[];
	}
	class PolyVariantResolver<T extends PsiPolyVariantReference> {
	}


	interface PolyVariantResolver<T extends PsiPolyVariantReference> extends ResolveCache.AbstractResolver<T, ResolveResult[]> {}	class AbstractResolver<TRef extends PsiReference, TResult> extends Object {
		resolve(arg1 : TRef, arg2 : boolean) : TResult;
	}
}

export = ResolveCache
