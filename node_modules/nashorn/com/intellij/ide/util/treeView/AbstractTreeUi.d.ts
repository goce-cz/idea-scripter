import Object = require('nashorn/java/lang/Object');
import ProgressIndicator = require('nashorn/com/intellij/openapi/progress/ProgressIndicator');
import AbstractTreeStructure = require('nashorn/com/intellij/ide/util/treeView/AbstractTreeStructure');
import JTree = require('nashorn/javax/swing/JTree');
import ActionCallback = require('nashorn/com/intellij/openapi/util/ActionCallback');
import Map = require('nashorn/java/util/Map');
import List = require('nashorn/java/util/List');
import DefaultTreeModel = require('nashorn/javax/swing/tree/DefaultTreeModel');
import Comparator = require('nashorn/java/util/Comparator');
import AbstractTreeUpdater = require('nashorn/com/intellij/ide/util/treeView/AbstractTreeUpdater');
import DefaultMutableTreeNode = require('nashorn/javax/swing/tree/DefaultMutableTreeNode');
import Collection = require('nashorn/java/util/Collection');
import TreeUpdatePass = require('nashorn/com/intellij/ide/util/treeView/TreeUpdatePass');
import AbstractTreeBuilder = require('nashorn/com/intellij/ide/util/treeView/AbstractTreeBuilder');
import NodeDescriptor = require('nashorn/com/intellij/ide/util/treeView/NodeDescriptor');
import Runnable = require('nashorn/java/lang/Runnable');
import AsyncResult = require('nashorn/com/intellij/openapi/util/AsyncResult');
import Set = require('nashorn/java/util/Set');
import UpdaterTreeState = require('nashorn/com/intellij/ide/util/treeView/UpdaterTreeState');
import TreePath = require('nashorn/javax/swing/tree/TreePath');
import Pair = require('nashorn/com/intellij/openapi/util/Pair');
import TreeNode = require('nashorn/javax/swing/tree/TreeNode');
import MutualMap = require('nashorn/com/intellij/openapi/util/MutualMap');
import ActiveRunnable = require('nashorn/com/intellij/openapi/util/ActiveRunnable');
import Computable = require('nashorn/com/intellij/openapi/util/Computable');
import Progressive = require('nashorn/com/intellij/openapi/progress/Progressive');
import Condition = require('nashorn/com/intellij/openapi/util/Condition');
import MutableTreeNode = require('nashorn/javax/swing/tree/MutableTreeNode');
import TreeExpansionListener = require('nashorn/javax/swing/event/TreeExpansionListener');
import TreeSelectionListener = require('nashorn/javax/swing/event/TreeSelectionListener');

declare class AbstractTreeUi extends Object {
	progress : ProgressIndicator;
	released : boolean;
	treeStructure : AbstractTreeStructure;
	tree : JTree;
	yeildingNow : boolean;
	ready : boolean;
	cancelledReady : boolean;
	status : string;
	idle : boolean;
	clearOnHideDelay : number;
	initialized : ActionCallback;
	nodeActions : Map<Object, List<AbstractTreeUi.NodeAction>>;
	expandedElements : List<Object>;
	cancelProcessed : boolean;
	toPaintSelection : boolean;
	releaseRequested : boolean;
	workerBusy : boolean;
	treeModel : DefaultTreeModel;
	nodeDescriptorComparator : Comparator;
	selectionBeingAdjusted : boolean;
	updater : AbstractTreeUpdater;
	rootNode : DefaultMutableTreeNode;
	yeildingPasses : Collection<TreeUpdatePass>;
	passthroughMode : boolean;
	constructor();
	init(arg1 : AbstractTreeBuilder, arg2 : JTree, arg3 : DefaultTreeModel, arg4 : AbstractTreeStructure, arg5 : Comparator<NodeDescriptor>, arg6 : boolean) : void;
	isNodeActionsPending() : boolean;
	clearNodeActions() : void;
	maybeSetBusyAndScheduleWaiterForReady(arg1 : boolean, arg2 : Object) : void;
	setHoldSize(arg1 : boolean) : void;
	cleanUpAll() : void;
	doCleanUp() : void;
	invokeLaterIfNeeded(arg1 : boolean, arg2 : Runnable) : ActionCallback;
	activate(arg1 : boolean) : void;
	cancelCurrentCleanupTask() : void;
	deactivate() : void;
	scheduleCleanUpAll() : void;
	requestRelease() : void;
	getProgress() : ProgressIndicator;
	releaseNow() : void;
	isReleased() : boolean;
	doExpandNodeChildren(arg1 : DefaultMutableTreeNode) : void;
	getTreeStructure() : AbstractTreeStructure;
	getTree() : JTree;
	static getDescriptorFrom(arg1 : Object) : NodeDescriptor;
	getNodeForElement(arg1 : Object, arg2 : boolean) : DefaultMutableTreeNode;
	isNodeInStructure(arg1 : DefaultMutableTreeNode) : boolean;
	isNodeValidForElement(arg1 : Object, arg2 : DefaultMutableTreeNode) : boolean;
	isValidChildOfParent(arg1 : Object, arg2 : DefaultMutableTreeNode) : boolean;
	isSameHierarchy(arg1 : Object, arg2 : DefaultMutableTreeNode) : boolean;
	getNodeForPath(arg1 : Object[]) : DefaultMutableTreeNode;
	buildNodeForElement(arg1 : Object) : void;
	buildNodeForPath(arg1 : Object[]) : void;
	setNodeDescriptorComparator(arg1 : Comparator<NodeDescriptor>) : void;
	getBuilder() : AbstractTreeBuilder;
	initRootNode() : void;
	initRootNodeNowIfNeeded(arg1 : TreeUpdatePass) : boolean;
	isAutoExpand(arg1 : NodeDescriptor) : boolean;
	isAutoExpand(arg1 : NodeDescriptor, arg2 : boolean) : boolean;
	validateAutoExpand(arg1 : boolean, arg2 : Object) : boolean;
	isInVisibleAutoExpandChain(arg1 : DefaultMutableTreeNode) : boolean;
	getDistanceToAutoExpandRoot(arg1 : Object) : number;
	isAutoExpand(arg1 : DefaultMutableTreeNode) : boolean;
	isAlwaysExpandedTree() : boolean;
	update(arg1 : NodeDescriptor, arg2 : boolean) : AsyncResult<boolean>;
	update(arg1 : NodeDescriptor) : boolean;
	assertIsDispatchThread() : void;
	static isEdt() : boolean;
	isTreeShowing() : boolean;
	assertNotDispatchThread() : void;
	processDeferredActions() : void;
	static processDeferredActions(arg1 : Set<Runnable>) : void;
	queueUpdate(arg1 : Object) : ActionCallback;
	queueUpdate(arg1 : Object, arg2 : boolean) : ActionCallback;
	doUpdateFromRoot() : void;
	updateSubtree(arg1 : DefaultMutableTreeNode, arg2 : boolean) : void;
	updateSubtree(arg1 : TreeUpdatePass, arg2 : boolean) : void;
	updateSubtreeNow(arg1 : TreeUpdatePass, arg2 : boolean) : void;
	updateRow(arg1 : number, arg2 : TreeUpdatePass) : void;
	isToBuildInBackground(arg1 : NodeDescriptor) : boolean;
	setUpdaterState(arg1 : UpdaterTreeState) : UpdaterTreeState;
	doUpdateNode(arg1 : DefaultMutableTreeNode) : void;
	getElementFromDescriptor(arg1 : NodeDescriptor) : Object;
	updateNodeChildren(arg1 : DefaultMutableTreeNode, arg2 : TreeUpdatePass, arg3 : AbstractTreeUi.LoadedChildren, arg4 : boolean, arg5 : boolean, arg6 : boolean, arg7 : boolean, arg8 : boolean) : ActionCallback;
	doUpdateChildren(arg1 : DefaultMutableTreeNode, arg2 : TreeUpdatePass, arg3 : AbstractTreeUi.LoadedChildren, arg4 : boolean, arg5 : boolean, arg6 : boolean, arg7 : boolean, arg8 : boolean) : void;
	processAlwaysLeaf(arg1 : DefaultMutableTreeNode) : boolean;
	isChildNodeForceUpdate(arg1 : DefaultMutableTreeNode, arg2 : boolean, arg3 : boolean) : boolean;
	updateNodeChildrenNow(arg1 : DefaultMutableTreeNode, arg2 : TreeUpdatePass, arg3 : AbstractTreeUi.LoadedChildren, arg4 : boolean, arg5 : boolean, arg6 : boolean) : void;
	isDisposed(arg1 : DefaultMutableTreeNode) : boolean;
	expandSilently(arg1 : TreePath) : void;
	addSelectionSilently(arg1 : TreePath) : void;
	expand(arg1 : DefaultMutableTreeNode, arg2 : boolean) : void;
	expand(arg1 : TreePath, arg2 : boolean) : void;
	addToUnbuilt(arg1 : DefaultMutableTreeNode) : void;
	removeFromUnbuilt(arg1 : DefaultMutableTreeNode) : void;
	processUnbuilt(arg1 : DefaultMutableTreeNode, arg2 : NodeDescriptor, arg3 : TreeUpdatePass, arg4 : boolean, arg5 : AbstractTreeUi.LoadedChildren) : Pair<boolean, AbstractTreeUi.LoadedChildren>;
	removeIfLoading(arg1 : TreeNode) : boolean;
	moveSelectionToParentIfNeeded(arg1 : TreeNode) : void;
	getChildrenFor(arg1 : Object) : Object[];
	warnOnIndexNotReady() : void;
	updateNodesToInsert(arg1 : List<TreeNode>, arg2 : TreeUpdatePass, arg3 : boolean, arg4 : boolean) : ActionCallback;
	processExistingNodes(arg1 : DefaultMutableTreeNode, arg2 : MutualMap<Object, number>, arg3 : TreeUpdatePass, arg4 : boolean, arg5 : boolean, arg6 : boolean, arg7 : AbstractTreeUi.LoadedChildren) : ActionCallback;
	isRerunNeeded(arg1 : TreeUpdatePass) : boolean;
	maybeYeild(arg1 : ActiveRunnable, arg2 : TreeUpdatePass, arg3 : DefaultMutableTreeNode) : ActionCallback;
	execute(arg1 : ActiveRunnable) : ActionCallback;
	execute(arg1 : Runnable) : void;
	canInitiateNewActivity() : boolean;
	resetToReady() : ActionCallback;
	resetToReadyNow() : ActionCallback;
	addToCancelled(arg1 : DefaultMutableTreeNode) : void;
	removeFromCancelled(arg1 : DefaultMutableTreeNode) : void;
	isCancelled(arg1 : Object) : boolean;
	resetIncompleteNode(arg1 : DefaultMutableTreeNode) : void;
	yieldAndRun(arg1 : Runnable, arg2 : TreeUpdatePass) : boolean;
	isYeildingNow() : boolean;
	hasScheduledUpdates() : boolean;
	isReady() : boolean;
	isCancelledReady() : boolean;
	isReady(arg1 : boolean) : boolean;
	checkValue(arg1 : Computable<boolean>, arg2 : boolean) : boolean;
	getStatus() : string;
	hasPendingWork() : boolean;
	isIdle() : boolean;
	executeYieldingRequest(arg1 : Runnable, arg2 : TreeUpdatePass) : void;
	maybeYeildingFinished() : void;
	maybeReady() : void;
	flushPendingNodeActions() : void;
	runOnYieldingDone(arg1 : Runnable) : void;
	yield(arg1 : Runnable) : void;
	isToYieldUpdateFor(arg1 : DefaultMutableTreeNode) : boolean;
	loadElementsFromStructure(arg1 : NodeDescriptor, arg2 : AbstractTreeUi.LoadedChildren) : MutualMap<Object, number>;
	static isLoadingNode(arg1 : Object) : boolean;
	collectNodesToInsert(arg1 : NodeDescriptor, arg2 : MutualMap<Object, number>, arg3 : DefaultMutableTreeNode, arg4 : boolean, arg5 : AbstractTreeUi.LoadedChildren) : AsyncResult<List<TreeNode>>;
	createChildNode(arg1 : NodeDescriptor) : DefaultMutableTreeNode;
	canYield() : boolean;
	getClearOnHideDelay() : number;
	getInitialized() : ActionCallback;
	getReady(arg1 : Object) : ActionCallback;
	_getReady() : ActionCallback;
	addToUpdatingChildren(arg1 : DefaultMutableTreeNode) : void;
	removeFromUpdatingChildren(arg1 : DefaultMutableTreeNode) : void;
	isUpdatingChildrenNow(arg1 : DefaultMutableTreeNode) : boolean;
	isParentUpdatingChildrenNow(arg1 : DefaultMutableTreeNode) : boolean;
	hasUpdatingChildrenNow() : boolean;
	getNodeActions() : Map<Object, List<AbstractTreeUi.NodeAction>>;
	getLoadedChildrenFor(arg1 : Object) : List<Object>;
	hasNodesToUpdate() : boolean;
	getExpandedElements() : List<Object>;
	cancelUpdate() : ActionCallback;
	setCancelRequested(arg1 : boolean) : void;
	attemptLock() : boolean;
	acquireLock() : void;
	releaseLock() : void;
	batch(arg1 : Progressive) : ActionCallback;
	isCancelProcessed() : boolean;
	isToPaintSelection() : boolean;
	isReleaseRequested() : boolean;
	executeUserRunnable(arg1 : Runnable) : void;
	isUpdatingParent(arg1 : DefaultMutableTreeNode) : boolean;
	getUpdatingParent(arg1 : DefaultMutableTreeNode) : DefaultMutableTreeNode;
	isLoadedInBackground(arg1 : Object) : boolean;
	getLoadedInBackground(arg1 : Object) : AbstractTreeUi.UpdateInfo;
	addToLoadedInBackground(arg1 : Object, arg2 : AbstractTreeUi.UpdateInfo) : void;
	removeFromLoadedInBackground(arg1 : Object) : void;
	isLoadingInBackgroundNow() : boolean;
	queueBackgroundUpdate(arg1 : AbstractTreeUi.UpdateInfo, arg2 : DefaultMutableTreeNode) : boolean;
	isExpanded(arg1 : DefaultMutableTreeNode, arg2 : boolean) : boolean;
	removeLoading(arg1 : DefaultMutableTreeNode, arg2 : boolean) : void;
	processNodeActionsIfReady(arg1 : DefaultMutableTreeNode) : void;
	static processActions(arg1 : DefaultMutableTreeNode, arg2 : Object, arg3 : Map<Object, List<AbstractTreeUi.NodeAction>>, arg4 : Map<Object, List<AbstractTreeUi.NodeAction>>) : void;
	canSmartExpand(arg1 : DefaultMutableTreeNode, arg2 : boolean) : boolean;
	processSmartExpand(arg1 : DefaultMutableTreeNode, arg2 : boolean, arg3 : boolean) : void;
	static getChildForSmartExpand(arg1 : DefaultMutableTreeNode) : TreeNode;
	static isLoadingChildrenFor(arg1 : Object) : boolean;
	isParentLoadingInBackground(arg1 : Object) : boolean;
	getParentLoadingInBackground(arg1 : Object) : DefaultMutableTreeNode;
	static getLoadingNodeText() : string;
	processExistingNode(arg1 : DefaultMutableTreeNode, arg2 : NodeDescriptor, arg3 : DefaultMutableTreeNode, arg4 : MutualMap<Object, number>, arg5 : TreeUpdatePass, arg6 : boolean, arg7 : boolean, arg8 : AbstractTreeUi.LoadedChildren) : ActionCallback;
	adjustSelectionOnChildRemove(arg1 : DefaultMutableTreeNode, arg2 : number, arg3 : Object) : void;
	isValidForSelectionAdjusting(arg1 : TreeNode) : boolean;
	getExpiredElementCondition(arg1 : Object) : Condition;
	addSelectionPath(arg1 : TreePath, arg2 : boolean, arg3 : Condition, arg4 : Object) : void;
	static getPathFor(arg1 : TreeNode) : TreePath;
	removeNodeFromParent(arg1 : MutableTreeNode, arg2 : boolean) : void;
	expandPath(arg1 : TreePath, arg2 : boolean) : void;
	processInnerChange(arg1 : Runnable) : void;
	isInnerChange() : boolean;
	makeLoadingOrLeafIfNoChildren(arg1 : DefaultMutableTreeNode) : void;
	isValid(arg1 : NodeDescriptor) : boolean;
	isValid(arg1 : Object) : boolean;
	insertLoadingNode(arg1 : DefaultMutableTreeNode, arg2 : boolean) : void;
	queueToBackground(arg1 : Runnable, arg2 : Runnable) : ActionCallback;
	registerWorkerTask(arg1 : Runnable) : void;
	unregisterWorkerTask(arg1 : Runnable, arg2 : Runnable) : void;
	isWorkerBusy() : boolean;
	clearWorkerTasks() : void;
	updateNodeImageAndPosition(arg1 : DefaultMutableTreeNode, arg2 : boolean, arg3 : boolean) : void;
	nodeChanged(arg1 : DefaultMutableTreeNode) : void;
	getTreeModel() : DefaultTreeModel;
	insertNodesInto(arg1 : List<TreeNode>, arg2 : DefaultMutableTreeNode) : void;
	sortChildren(arg1 : DefaultMutableTreeNode, arg2 : List<TreeNode>, arg3 : boolean, arg4 : boolean) : void;
	getNodeDescriptorComparator() : Comparator;
	disposeNode(arg1 : DefaultMutableTreeNode) : void;
	addSubtreeToUpdate(arg1 : DefaultMutableTreeNode) : boolean;
	addSubtreeToUpdate(arg1 : DefaultMutableTreeNode, arg2 : boolean) : boolean;
	addSubtreeToUpdate(arg1 : DefaultMutableTreeNode, arg2 : Runnable) : boolean;
	addSubtreeToUpdate(arg1 : DefaultMutableTreeNode, arg2 : Runnable, arg3 : boolean) : boolean;
	wasRootNodeInitialized() : boolean;
	select(arg1 : Object[], arg2 : Runnable) : void;
	select(arg1 : Object[], arg2 : Runnable, arg3 : boolean) : void;
	select(arg1 : Object[], arg2 : Runnable, arg3 : boolean, arg4 : boolean) : void;
	_select(arg1 : Object[], arg2 : Runnable, arg3 : boolean, arg4 : boolean, arg5 : boolean) : void;
	_select(arg1 : Object[], arg2 : Runnable, arg3 : boolean, arg4 : boolean, arg5 : boolean, arg6 : boolean) : void;
	userSelect(arg1 : Object[], arg2 : Runnable, arg3 : boolean, arg4 : boolean) : void;
	_select(arg1 : Object[], arg2 : Runnable, arg3 : boolean, arg4 : boolean, arg5 : boolean, arg6 : boolean, arg7 : boolean, arg8 : boolean, arg9 : boolean) : void;
	clearSelection() : void;
	isSelectionBeingAdjusted() : boolean;
	restoreSelection(arg1 : Set<Object>) : void;
	addToDeferred(arg1 : Object[], arg2 : Runnable, arg3 : boolean) : void;
	checkDeferred(arg1 : boolean, arg2 : Runnable) : boolean;
	getSelectedElements() : Set<Object>;
	addNext(arg1 : Object[], arg2 : number, arg3 : Runnable, arg4 : number[], arg5 : boolean, arg6 : boolean, arg7 : boolean) : void;
	select(arg1 : Object, arg2 : Runnable) : void;
	select(arg1 : Object, arg2 : Runnable, arg3 : boolean) : void;
	doSelect(arg1 : Object, arg2 : Runnable, arg3 : boolean, arg4 : boolean, arg5 : boolean, arg6 : boolean, arg7 : boolean) : void;
	checkPathAndMaybeRevalidate(arg1 : Object, arg2 : Runnable, arg3 : boolean, arg4 : boolean, arg5 : boolean) : void;
	scrollSelectionToVisible(arg1 : Runnable, arg2 : boolean) : void;
	selectVisible(arg1 : Object, arg2 : Runnable, arg3 : boolean, arg4 : boolean, arg5 : boolean) : void;
	getRowIfUnderSelection(arg1 : Object) : number;
	expandAllWithoutRecursion(arg1 : Runnable) : void;
	expandAll(arg1 : Runnable) : void;
	expand(arg1 : Object, arg2 : Runnable) : void;
	expand(arg1 : Object[], arg2 : Runnable) : void;
	expand(arg1 : Object[], arg2 : Runnable, arg3 : boolean) : void;
	_expand(arg1 : Object[], arg2 : Runnable, arg3 : boolean, arg4 : boolean, arg5 : boolean) : void;
	expandNext(arg1 : Object[], arg2 : number, arg3 : boolean, arg4 : boolean, arg5 : boolean, arg6 : ActionCallback, arg7 : number) : void;
	collapseChildren(arg1 : Object, arg2 : Runnable) : void;
	runDone(arg1 : Runnable) : void;
	_expand(arg1 : Object, arg2 : Runnable, arg3 : boolean, arg4 : boolean, arg5 : boolean) : void;
	deferExpansion(arg1 : Object, arg2 : Runnable, arg3 : boolean, arg4 : boolean) : void;
	processExpand(arg1 : DefaultMutableTreeNode, arg2 : List<Object>, arg3 : number, arg4 : Runnable, arg5 : boolean) : void;
	areChildrenToBeUpdated(arg1 : DefaultMutableTreeNode) : boolean;
	getElementFor(arg1 : Object) : Object;
	getElementFor(arg1 : DefaultMutableTreeNode) : Object;
	isNodeBeingBuilt(arg1 : TreePath) : boolean;
	isNodeBeingBuilt(arg1 : Object) : boolean;
	getParentBuiltNode(arg1 : Object) : DefaultMutableTreeNode;
	isLoadingParentInBackground(arg1 : Object) : boolean;
	setTreeStructure(arg1 : AbstractTreeStructure) : void;
	getUpdater() : AbstractTreeUpdater;
	setUpdater(arg1 : AbstractTreeUpdater) : void;
	getRootNode() : DefaultMutableTreeNode;
	setRootNode(arg1 : DefaultMutableTreeNode) : void;
	dropUpdaterStateIfExternalChange() : void;
	clearUpdaterState() : void;
	createMapping(arg1 : Object, arg2 : DefaultMutableTreeNode) : void;
	removeMapping(arg1 : Object, arg2 : DefaultMutableTreeNode, arg3 : Object) : void;
	remapNodeActions(arg1 : Object, arg2 : Object) : void;
	static _remapNodeActions(arg1 : Object, arg2 : Object, arg3 : Map<Object, List<AbstractTreeUi.NodeAction>>) : void;
	getFirstNode(arg1 : Object) : DefaultMutableTreeNode;
	findNode(arg1 : Object, arg2 : number) : DefaultMutableTreeNode;
	findNodeByElement(arg1 : Object) : Object;
	findNodeForChildElement(arg1 : DefaultMutableTreeNode, arg2 : Object) : DefaultMutableTreeNode;
	addNodeAction(arg1 : Object, arg2 : AbstractTreeUi.NodeAction, arg3 : boolean) : void;
	addActivity() : void;
	removeActivity() : void;
	_addNodeAction(arg1 : Object, arg2 : AbstractTreeUi.NodeAction, arg3 : Map<Object, List<AbstractTreeUi.NodeAction>>) : void;
	cleanUpNow() : void;
	setClearOnHideDelay(arg1 : number) : AbstractTreeUi;
	removeChildren(arg1 : DefaultMutableTreeNode) : void;
	maybeUpdateSubtreeToUpdate(arg1 : DefaultMutableTreeNode) : void;
	isSelectionInside(arg1 : DefaultMutableTreeNode) : boolean;
	isInStructure(arg1 : Object) : boolean;
	setCanYield(arg1 : boolean) : void;
	getYeildingPasses() : Collection<TreeUpdatePass>;
	getComparatorStamp() : number;
	incComparatorStamp() : void;
	setPassthroughMode(arg1 : boolean) : void;
	isPassthroughMode() : boolean;
	static isUnitTestingMode() : boolean;
	addModelListenerToDianoseAccessOutsideEdt() : void;
}


declare module AbstractTreeUi {
	class UpdateInfo extends Object {
		updateChildren : boolean;
		constructor(arg1 : NodeDescriptor, arg2 : TreeUpdatePass, arg3 : boolean, arg4 : boolean, arg5 : boolean, arg6 : boolean, arg7 : boolean);
		getDescriptor() : NodeDescriptor;
		getPass() : TreeUpdatePass;
		isCanSmartExpand() : boolean;
		isWasExpanded() : boolean;
		isForceUpdate() : boolean;
		isDescriptorIsUpToDate() : boolean;
		apply(arg1 : AbstractTreeUi.UpdateInfo) : void;
		isUpdateChildren() : boolean;
	}
	class LoadedChildren extends Object {
		putDescriptor(arg1 : Object, arg2 : NodeDescriptor, arg3 : boolean) : void;
		getElements() : List<Object>;
		getDescriptor(arg1 : Object) : NodeDescriptor;
		isUpdated(arg1 : Object) : boolean;
	}
	class NodeAction extends Object {
		onReady(arg1 : DefaultMutableTreeNode) : void;
	}
	class MyExpansionListener {
	}


	interface MyExpansionListener extends TreeExpansionListener {}	class MySelectionListener {
	}


	interface MySelectionListener extends TreeSelectionListener {}	class ElementNode {
		isValidChild(arg1 : Object) : boolean;
	}


	interface ElementNode extends DefaultMutableTreeNode {}}

export = AbstractTreeUi
