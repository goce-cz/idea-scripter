import File = require('nashorn/java/io/File');
import ByteBufferWrapper = require('nashorn/com/intellij/util/io/ByteBufferWrapper');
import ByteBuffer = require('nashorn/java/nio/ByteBuffer');
import Forceable = require('nashorn/com/intellij/openapi/Forceable');
import Object = require('nashorn/java/lang/Object');
import Map = require('nashorn/java/util/Map');

declare class PagedFileStorage {
	static MB : number;
	static BUFFER_SIZE : number;
	storageLockContext : PagedFileStorage.StorageLockContext;
	file : File;
	dirty : boolean;
	constructor(arg1 : File, arg2 : PagedFileStorage.StorageLock, arg3 : number, arg4 : boolean);
	constructor(arg1 : File, arg2 : PagedFileStorage.StorageLockContext, arg3 : number, arg4 : boolean);
	constructor(arg1 : File, arg2 : PagedFileStorage.StorageLockContext, arg3 : number, arg4 : boolean, arg5 : boolean);
	constructor(arg1 : File, arg2 : PagedFileStorage.StorageLock);
	lock() : void;
	unlock() : void;
	getStorageLockContext() : PagedFileStorage.StorageLockContext;
	getFile() : File;
	putInt(arg1 : number, arg2 : number) : void;
	getInt(arg1 : number) : number;
	putShort(arg1 : number, arg2 : number) : void;
	getOffsetInPage(arg1 : number) : number;
	getByteBuffer(arg1 : number, arg2 : boolean) : ByteBufferWrapper;
	getShort(arg1 : number) : number;
	putLong(arg1 : number, arg2 : number) : void;
	putByte(arg1 : number, arg2 : number) : void;
	getByte(arg1 : number) : number;
	getLong(arg1 : number) : number;
	get(arg1 : number) : number;
	put(arg1 : number, arg2 : number) : void;
	get(arg1 : number, arg2 : number[], arg3 : number, arg4 : number) : void;
	put(arg1 : number, arg2 : number[], arg3 : number, arg4 : number) : void;
	close() : void;
	unmapAll() : void;
	resize(arg1 : number) : void;
	resizeFile(arg1 : number) : void;
	fillWithZeros(arg1 : number, arg2 : number) : void;
	length() : number;
	getBuffer(arg1 : number) : ByteBuffer;
	getReadOnlyBuffer(arg1 : number) : ByteBuffer;
	getBufferWrapper(arg1 : number, arg2 : boolean) : ByteBufferWrapper;
	markDirty(arg1 : ByteBufferWrapper) : void;
}


declare interface PagedFileStorage extends Forceable {}

declare module PagedFileStorage {
	class StorageLockContext extends Object {
		constructor(arg1 : PagedFileStorage.StorageLock);
		constructor(arg1 : boolean);
		lock() : void;
		unlock() : void;
	}
	class StorageLock extends Object {
		myDefaultStorageLockContext : PagedFileStorage.StorageLockContext;
		constructor();
		constructor(arg1 : boolean);
		lock() : void;
		unlock() : void;
		registerPagedFileStorage(arg1 : PagedFileStorage) : number;
		getRegisteredPagedFileStorageByIndex(arg1 : number) : PagedFileStorage;
		get(arg1 : number) : ByteBufferWrapper;
		disposeRemovedSegments() : void;
		ensureSize(arg1 : number) : void;
		createValue(arg1 : number) : ByteBufferWrapper;
		static checkThreadAccess(arg1 : PagedFileStorage.StorageLockContext) : void;
		getBuffersOrderedForOwner(arg1 : number, arg2 : PagedFileStorage.StorageLockContext) : Map<number, ByteBufferWrapper>;
		unmapBuffersForOwner(arg1 : number, arg2 : PagedFileStorage.StorageLockContext) : void;
		flushBuffersForOwner(arg1 : number, arg2 : PagedFileStorage.StorageLockContext) : void;
		invalidateBuffer(arg1 : number) : void;
	}
}

export = PagedFileStorage
