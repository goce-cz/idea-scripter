import ContentIterator = require('nashorn/com/intellij/openapi/roots/ContentIterator');
import Project = require('nashorn/com/intellij/openapi/project/Project');
import ProgressIndicator = require('nashorn/com/intellij/openapi/progress/ProgressIndicator');
import IndexableFileSet = require('nashorn/com/intellij/util/indexing/IndexableFileSet');
import VirtualFile = require('nashorn/com/intellij/openapi/vfs/VirtualFile');
import ID = require('nashorn/com/intellij/util/indexing/ID');
import GlobalSearchScope = require('nashorn/com/intellij/psi/search/GlobalSearchScope');
import List = require('nashorn/java/util/List');
import Collection = require('nashorn/java/util/Collection');
import IdFilter = require('nashorn/com/intellij/util/indexing/IdFilter');
import Condition = require('nashorn/com/intellij/openapi/util/Condition');
import Processor = require('nashorn/com/intellij/util/Processor');
import Throwable = require('nashorn/java/lang/Throwable');
import Set = require('nashorn/java/util/Set');
import BaseComponent = require('nashorn/com/intellij/openapi/components/BaseComponent');
import Consumer = require('nashorn/com/intellij/util/Consumer');
import FileType = require('nashorn/com/intellij/openapi/fileTypes/FileType');
import Object = require('nashorn/java/lang/Object');

declare class FileBasedIndex {
	static ourEnableTracingOfKeyHashToVirtualFileMapping : boolean;
	static instance : FileBasedIndex;
	componentName : string;
	constructor();
	iterateIndexableFiles(arg1 : ContentIterator, arg2 : Project, arg3 : ProgressIndicator) : void;
	registerIndexableSet(arg1 : IndexableFileSet, arg2 : Project) : void;
	removeIndexableSet(arg1 : IndexableFileSet) : void;
	static getInstance() : FileBasedIndex;
	static getFileId(arg1 : VirtualFile) : number;
	findFileById(arg1 : Project, arg2 : number) : VirtualFile;
	requestRebuild(arg1 : ID<any, any>) : void;
	getValues<K, V>(arg1 : ID<K, V>, arg2 : K, arg3 : GlobalSearchScope) : List<V>;
	getContainingFiles<K, V>(arg1 : ID<K, V>, arg2 : K, arg3 : GlobalSearchScope) : Collection<VirtualFile>;
	processValues<K, V>(arg1 : ID<K, V>, arg2 : K, arg3 : VirtualFile, arg4 : FileBasedIndex.ValueProcessor<V>, arg5 : GlobalSearchScope) : boolean;
	processValues<K, V>(arg1 : ID<K, V>, arg2 : K, arg3 : VirtualFile, arg4 : FileBasedIndex.ValueProcessor<V>, arg5 : GlobalSearchScope, arg6 : IdFilter) : boolean;
	processFilesContainingAllKeys<K, V>(arg1 : ID<K, V>, arg2 : Collection<K>, arg3 : GlobalSearchScope, arg4 : Condition<V>, arg5 : Processor<VirtualFile>) : boolean;
	getAllKeys<K>(arg1 : ID<K, any>, arg2 : Project) : Collection<K>;
	ensureUpToDate<K>(arg1 : ID<K, any>, arg2 : Project, arg3 : GlobalSearchScope) : void;
	requestRebuild(arg1 : ID<any, any>, arg2 : Throwable) : void;
	scheduleRebuild<K>(arg1 : ID<K, any>, arg2 : Throwable) : void;
	requestReindex(arg1 : VirtualFile) : void;
	getFilesWithKey<K, V>(arg1 : ID<K, V>, arg2 : Set<K>, arg3 : Processor<VirtualFile>, arg4 : GlobalSearchScope) : boolean;
	processAllKeys<K>(arg1 : ID<K, any>, arg2 : Processor<K>, arg3 : Project) : boolean;
	processAllKeys<K>(arg1 : ID<K, any>, arg2 : Processor<K>, arg3 : GlobalSearchScope, arg4 : IdFilter) : boolean;
}


declare interface FileBasedIndex extends BaseComponent {}

declare module FileBasedIndex {
	class FileTypeSpecificInputFilter {
		registerFileTypesUsedForIndexing(arg1 : Consumer<FileType>) : void;
	}


	interface FileTypeSpecificInputFilter extends FileBasedIndex.InputFilter {}	class InputFilter extends Object {
		acceptInput(arg1 : VirtualFile) : boolean;
	}
	class ValueProcessor<V> extends Object {
		process(arg1 : VirtualFile, arg2 : V) : boolean;
	}
}

export = FileBasedIndex
