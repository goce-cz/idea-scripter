import TObjectHashingStrategy = require('nashorn/gnu/trove/TObjectHashingStrategy');
import ReferenceQueue = require('nashorn/java/lang/ref/ReferenceQueue');
import Object = require('nashorn/java/lang/Object');
import ConcurrentMap = require('nashorn/java/util/concurrent/ConcurrentMap');
import SoftReference = require('nashorn/java/lang/ref/SoftReference');
import WeakReference = require('nashorn/java/lang/ref/WeakReference');
import Getter = require('nashorn/com/intellij/openapi/util/Getter');

declare class ConcurrentWeakKeySoftValueHashMap<K, V> {
	empty : boolean;
	constructor(arg1 : number, arg2 : number, arg3 : number, arg4 : TObjectHashingStrategy<K>);
	createKeyReference(arg1 : K, arg2 : V) : ConcurrentWeakKeySoftValueHashMap.KeyReference<K, V>;
	createValueReference(arg1 : V, arg2 : ReferenceQueue<V>) : ConcurrentWeakKeySoftValueHashMap.ValueReference<K, V>;
	createHardKey(arg1 : Object) : ConcurrentWeakKeySoftValueHashMap.HardKey<K, V>;
	processQueues() : boolean;
}


declare interface ConcurrentWeakKeySoftValueHashMap<K, V> extends ConcurrentMap<K, V> {}

declare module ConcurrentWeakKeySoftValueHashMap {
	class HardKey<K, V> {
		valueReference : ConcurrentWeakKeySoftValueHashMap.ValueReference<K, V>;
		set(arg1 : K, arg2 : number) : void;
		clear() : void;
	}


	interface HardKey<K, V> extends ConcurrentWeakKeySoftValueHashMap.KeyReference<K, V> {}	class SoftValue<K, V> {
		keyReference : ConcurrentWeakKeySoftValueHashMap.KeyReference<K, V>;
	}


	interface SoftValue<K, V> extends SoftReference<V>, ConcurrentWeakKeySoftValueHashMap.ValueReference<K, V> {}	class WeakKey<K, V> {
		valueReference : ConcurrentWeakKeySoftValueHashMap.ValueReference<K, V>;
	}


	interface WeakKey<K, V> extends WeakReference<K>, ConcurrentWeakKeySoftValueHashMap.KeyReference<K, V> {}	class ValueReference<K, V> {
		keyReference : ConcurrentWeakKeySoftValueHashMap.KeyReference<K, V>;
		getKeyReference() : ConcurrentWeakKeySoftValueHashMap.KeyReference<K, V>;
	}


	interface ValueReference<K, V> extends Getter<V> {}	class KeyReference<K, V> {
		valueReference : ConcurrentWeakKeySoftValueHashMap.ValueReference<K, V>;
		getValueReference() : ConcurrentWeakKeySoftValueHashMap.ValueReference<K, V>;
	}


	interface KeyReference<K, V> extends Getter<K> {}}

export = ConcurrentWeakKeySoftValueHashMap
