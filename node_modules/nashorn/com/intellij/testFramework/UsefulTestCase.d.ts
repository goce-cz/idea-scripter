import Map = require('nashorn/java/util/Map');
import Disposable = require('nashorn/com/intellij/openapi/Disposable');
import CompositeException = require('nashorn/com/intellij/testFramework/CompositeException');
import CodeStyleSettings = require('nashorn/com/intellij/psi/codeStyle/CodeStyleSettings');
import Runnable = require('nashorn/java/lang/Runnable');
import Iterable = require('nashorn/java/lang/Iterable');
import Collection = require('nashorn/java/util/Collection');
import Consumer = require('nashorn/com/intellij/util/Consumer');
import Object = require('nashorn/java/lang/Object');
import Throwable = require('nashorn/java/lang/Throwable');
import Class = require('nashorn/java/lang/Class');
import File = require('nashorn/java/io/File');
import Project = require('nashorn/com/intellij/openapi/project/Project');
import AbstractExceptionCase = require('nashorn/com/intellij/testFramework/exceptionCases/AbstractExceptionCase');
import VirtualFile = require('nashorn/com/intellij/openapi/vfs/VirtualFile');
import Test = require('nashorn/junit/framework/Test');
import Exception = require('nashorn/java/lang/Exception');
import ThrowableRunnable = require('nashorn/com/intellij/util/ThrowableRunnable');
import TestCase = require('nashorn/junit/framework/TestCase');

declare class UsefulTestCase {
	static IS_UNDER_TEAMCITY : boolean;
	static IDEA_MARKER_CLASS : string;
	static TEMP_DIR_MARKER : string;
	static TOTAL_SETUP_COST_MILLIS : Map<string, number>;
	static TOTAL_TEARDOWN_COST_MILLIS : Map<string, number>;
	testRootDisposable : Disposable;
	performanceTest : boolean;
	constructor();
	shouldContainTempFiles() : boolean;
	static cleanupDeleteOnExitHookList() : void;
	static a() : void;
	checkForSettingsDamage() : CompositeException;
	static doCheckForSettingsDamage(arg1 : CodeStyleSettings, arg2 : CodeStyleSettings) : CompositeException;
	storeSettings() : void;
	getCurrentCodeStyleSettings() : CodeStyleSettings;
	getTestRootDisposable() : Disposable;
	shouldRunTest() : boolean;
	static edt(arg1 : Runnable) : void;
	invokeTestRunnable(arg1 : Runnable) : void;
	defaultRunBare() : void;
	a(arg1 : number, arg2 : Map<string, number>) : void;
	static logSetupTeardownCosts() : void;
	static replaceIdeEventQueueSafely() : void;
	runInDispatchThread() : boolean;
	static toString(arg1 : Iterable<any>) : string;
	static assertOrderedEquals<T>(arg1 : T[], arg2 : T[]) : void;
	static assertOrderedEquals<T>(arg1 : Iterable<T>, arg2 : T[]) : void;
	static assertOrderedEquals(arg1 : number[], arg2 : number[]) : void;
	static assertOrderedEquals<T>(arg1 : string, arg2 : Iterable<T>, arg3 : T[]) : void;
	static assertOrderedEquals<T>(arg1 : Iterable<T>, arg2 : Collection<T>) : void;
	static assertOrderedEquals<T>(arg1 : string, arg2 : Iterable<T>, arg3 : Collection<T>) : void;
	static assertOrderedCollection<T>(arg1 : T[], arg2 : Consumer<T>[]) : void;
	static assertSameElements<T>(arg1 : T[], arg2 : T[]) : void;
	static assertSameElements<T>(arg1 : Collection<T>, arg2 : T[]) : void;
	static assertSameElements<T>(arg1 : Collection<T>, arg2 : Collection<T>) : void;
	static assertSameElements<T>(arg1 : string, arg2 : Collection<T>, arg3 : Collection<T>) : void;
	assertContainsOrdered<T>(arg1 : Collection<T>, arg2 : T[]) : void;
	assertContainsOrdered<T>(arg1 : Collection<T>, arg2 : Collection<T>) : void;
	assertContainsElements<T>(arg1 : Collection<T>, arg2 : T[]) : void;
	assertContainsElements<T>(arg1 : Collection<T>, arg2 : Collection<T>) : void;
	static toString(arg1 : Object[], arg2 : string) : string;
	assertDoesntContain<T>(arg1 : Collection<T>, arg2 : T[]) : void;
	assertDoesntContain<T>(arg1 : Collection<T>, arg2 : Collection<T>) : void;
	static toString(arg1 : Collection<any>, arg2 : string) : string;
	static assertOrderedCollection<T>(arg1 : Collection<T>, arg2 : Consumer<T>[]) : void;
	static assertUnorderedCollection<T>(arg1 : T[], arg2 : Consumer<T>[]) : void;
	static assertUnorderedCollection<T>(arg1 : Collection<T>, arg2 : Consumer<T>[]) : void;
	static a<T>(arg1 : Consumer<T>, arg2 : T) : Throwable;
	static assertInstanceOf<T>(arg1 : Object, arg2 : Class<T>) : T;
	static assertOneElement<T>(arg1 : Collection<T>) : T;
	static assertOneElement<T>(arg1 : T[]) : T;
	static assertOneOf<T>(arg1 : T, arg2 : T[]) : void;
	static printThreadDump() : void;
	static assertEmpty(arg1 : Object[]) : void;
	static assertNotEmpty(arg1 : Collection<any>) : void;
	static assertEmpty(arg1 : Collection<any>) : void;
	static assertNullOrEmpty(arg1 : Collection<any>) : void;
	static assertEmpty(arg1 : string) : void;
	static assertEmpty<T>(arg1 : string, arg2 : Collection<T>) : void;
	static assertSize(arg1 : number, arg2 : Object[]) : void;
	static assertSize(arg1 : number, arg2 : Collection<any>) : void;
	disposeOnTearDown<T extends Disposable>(arg1 : T) : T;
	static assertSameLines(arg1 : string, arg2 : string) : void;
	static assertExists(arg1 : File) : void;
	static assertDoesntExist(arg1 : File) : void;
	getTestName(arg1 : boolean) : string;
	static getTestName(arg1 : string, arg2 : boolean) : string;
	static lowercaseFirstLetter(arg1 : string, arg2 : boolean) : string;
	static isAllUppercaseName(arg1 : string) : boolean;
	getTestDirectoryName() : string;
	static assertSameLinesWithFile(arg1 : string, arg2 : string) : void;
	static clearFields(arg1 : Object) : void;
	static clearDeclaredFields(arg1 : Object, arg2 : Class) : void;
	static checkSettingsEqual(arg1 : CodeStyleSettings, arg2 : CodeStyleSettings, arg3 : string) : void;
	isPerformanceTest() : boolean;
	static doPostponedFormatting(arg1 : Project) : void;
	static checkAllTimersAreDisposed() : void;
	assertException(arg1 : AbstractExceptionCase) : void;
	assertException(arg1 : AbstractExceptionCase, arg2 : string) : void;
	assertNoException(arg1 : AbstractExceptionCase) : void;
	assertNoThrowable(arg1 : Runnable) : void;
	static a(arg1 : boolean, arg2 : AbstractExceptionCase, arg3 : string) : void;
	annotatedWith(arg1 : Class) : boolean;
	getHomePath() : string;
	static isInHeadlessEnvironment() : boolean;
	static refreshRecursively(arg1 : VirtualFile) : void;
	static filteredSuite(arg1 : string, arg2 : Test) : Test;
	static refreshAndFindFile(arg1 : File) : VirtualFile;
	static invokeAndWaitIfNeeded<E extends Exception>(arg1 : ThrowableRunnable<E>) : void;
}


declare interface UsefulTestCase extends TestCase {}
export = UsefulTestCase
