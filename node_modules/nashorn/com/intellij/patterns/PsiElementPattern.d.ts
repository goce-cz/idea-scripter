import PsiElement = require('nashorn/com/intellij/psi/PsiElement');
import IElementType = require('nashorn/com/intellij/psi/tree/IElementType');
import TokenSet = require('nashorn/com/intellij/psi/tree/TokenSet');
import ElementPattern = require('nashorn/com/intellij/patterns/ElementPattern');
import Class = require('nashorn/java/lang/Class');
import PsiReference = require('nashorn/com/intellij/psi/PsiReference');
import PsiFile = require('nashorn/com/intellij/psi/PsiFile');
import VirtualFile = require('nashorn/com/intellij/openapi/vfs/VirtualFile');
import PatternCondition = require('nashorn/com/intellij/patterns/PatternCondition');
import Language = require('nashorn/com/intellij/lang/Language');
import PsiMetaData = require('nashorn/com/intellij/psi/meta/PsiMetaData');
import TreeElementPattern = require('nashorn/com/intellij/patterns/TreeElementPattern');

declare class PsiElementPattern<T extends PsiElement, Self extends PsiElementPattern<T, Self>> {
	withElementType(arg1 : IElementType) : Self;
	withElementType(arg1 : TokenSet) : Self;
	afterLeaf(arg1 : string[]) : Self;
	afterLeaf(arg1 : ElementPattern<PsiElement>) : Self;
	beforeLeaf(arg1 : ElementPattern<PsiElement>) : Self;
	whitespace() : Self;
	whitespaceCommentOrError() : Self;
	whitespaceCommentEmptyOrError() : Self;
	withFirstNonWhitespaceChild(arg1 : ElementPattern<PsiElement>) : Self;
	withReference(arg1 : Class<PsiReference>) : Self;
	inFile(arg1 : ElementPattern<PsiFile>) : Self;
	inVirtualFile(arg1 : ElementPattern<VirtualFile>) : Self;
	withElementType(arg1 : ElementPattern<IElementType>) : Self;
	withText(arg1 : string) : Self;
	withoutText(arg1 : string) : Self;
	withName(arg1 : string) : Self;
	withName(arg1 : string[]) : Self;
	withName(arg1 : ElementPattern<string>) : Self;
	afterLeafSkipping(arg1 : ElementPattern, arg2 : ElementPattern) : Self;
	beforeLeafSkipping(arg1 : ElementPattern, arg2 : ElementPattern) : Self;
	atStartOf(arg1 : ElementPattern) : Self;
	withTextLength(arg1 : ElementPattern) : Self;
	notEmpty() : Self;
	withTextLengthLongerThan(arg1 : number) : Self;
	withText(arg1 : ElementPattern) : Self;
	_withText(arg1 : ElementPattern) : PatternCondition<T>;
	withoutText(arg1 : ElementPattern) : Self;
	withLanguage(arg1 : Language) : Self;
	withMetaData(arg1 : ElementPattern<PsiMetaData>) : Self;
	referencing(arg1 : ElementPattern<PsiElement>) : Self;
	compiled() : Self;
	withTreeParent(arg1 : ElementPattern<PsiElement>) : Self;
	insideStarting(arg1 : ElementPattern<PsiElement>) : Self;
}


declare interface PsiElementPattern<T extends PsiElement, Self extends PsiElementPattern<T, Self>> extends TreeElementPattern<PsiElement, T, Self> {}

declare module PsiElementPattern {
	class Capture<T extends PsiElement> {
	}


	interface Capture<T extends PsiElement> extends PsiElementPattern<T, PsiElementPattern.Capture<T>> {}}

export = PsiElementPattern
