import Class = require('nashorn/java/lang/Class');
import ElementPattern = require('nashorn/com/intellij/patterns/ElementPattern');
import Collection = require('nashorn/java/util/Collection');
import ObjectPattern = require('nashorn/com/intellij/patterns/ObjectPattern');

declare class TreeElementPattern<ParentType, T extends ParentType, Self extends TreeElementPattern<ParentType, T, Self>> {
	getParent(arg1 : ParentType) : ParentType;
	getChildren(arg1 : ParentType) : ParentType[];
	withParents(arg1 : Class<ParentType>[]) : Self;
	withParent(arg1 : Class<ParentType>) : Self;
	withParent(arg1 : ElementPattern<ParentType>) : Self;
	withChild(arg1 : ElementPattern<ParentType>) : Self;
	withFirstChild(arg1 : ElementPattern<ParentType>) : Self;
	withLastChild(arg1 : ElementPattern<ParentType>) : Self;
	withChildren(arg1 : ElementPattern<Collection<ParentType>>) : Self;
	isFirstAcceptedChild(arg1 : ElementPattern<any>) : Self;
	withSuperParent(arg1 : number, arg2 : Class<ParentType>) : Self;
	withSuperParent(arg1 : number, arg2 : ElementPattern<ParentType>) : Self;
	inside(arg1 : Class<ParentType>) : Self;
	inside(arg1 : ElementPattern<ParentType>) : Self;
	inside(arg1 : boolean, arg2 : ElementPattern<ParentType>) : Self;
	inside(arg1 : boolean, arg2 : ElementPattern<ParentType>, arg3 : ElementPattern<ParentType>) : Self;
	insideSequence(arg1 : boolean, arg2 : ElementPattern<ParentType>[]) : Self;
	afterSibling(arg1 : ElementPattern<ParentType>) : Self;
	afterSiblingSkipping(arg1 : ElementPattern, arg2 : ElementPattern<ParentType>) : Self;
}


declare interface TreeElementPattern<ParentType, T extends ParentType, Self extends TreeElementPattern<ParentType, T, Self>> extends ObjectPattern<T, Self> {}
export = TreeElementPattern
