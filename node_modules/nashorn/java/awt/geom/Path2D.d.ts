import Point2D = require('nashorn/java/awt/geom/Point2D');
import Rectangle = require('nashorn/java/awt/Rectangle');
import AffineTransform = require('nashorn/java/awt/geom/AffineTransform');
import Shape = require('nashorn/java/awt/Shape');
import PathIterator = require('nashorn/java/awt/geom/PathIterator');
import Rectangle2D = require('nashorn/java/awt/geom/Rectangle2D');
import ObjectOutputStream = require('nashorn/java/io/ObjectOutputStream');
import ObjectInputStream = require('nashorn/java/io/ObjectInputStream');
import Cloneable = require('nashorn/java/lang/Cloneable');
import Serializable = require('nashorn/java/io/Serializable');

declare class Path2D {
	static WIND_EVEN_ODD : number;
	static WIND_NON_ZERO : number;
	windingRule : number;
	currentPoint : Point2D;
	bounds : Rectangle;
	cloneCoordsFloat(arg1 : AffineTransform) : number[];
	cloneCoordsDouble(arg1 : AffineTransform) : number[];
	append(arg1 : number, arg2 : number) : void;
	append(arg1 : number, arg2 : number) : void;
	getPoint(arg1 : number) : Point2D;
	needRoom(arg1 : boolean, arg2 : number) : void;
	pointCrossings(arg1 : number, arg2 : number) : number;
	rectCrossings(arg1 : number, arg2 : number, arg3 : number, arg4 : number) : number;
	moveTo(arg1 : number, arg2 : number) : void;
	lineTo(arg1 : number, arg2 : number) : void;
	quadTo(arg1 : number, arg2 : number, arg3 : number, arg4 : number) : void;
	curveTo(arg1 : number, arg2 : number, arg3 : number, arg4 : number, arg5 : number, arg6 : number) : void;
	closePath() : void;
	append(arg1 : Shape, arg2 : boolean) : void;
	append(arg1 : PathIterator, arg2 : boolean) : void;
	getWindingRule() : number;
	setWindingRule(arg1 : number) : void;
	getCurrentPoint() : Point2D;
	reset() : void;
	transform(arg1 : AffineTransform) : void;
	createTransformedShape(arg1 : AffineTransform) : Shape;
	static contains(arg1 : PathIterator, arg2 : number, arg3 : number) : boolean;
	static contains(arg1 : PathIterator, arg2 : Point2D) : boolean;
	static contains(arg1 : PathIterator, arg2 : number, arg3 : number, arg4 : number, arg5 : number) : boolean;
	static contains(arg1 : PathIterator, arg2 : Rectangle2D) : boolean;
	static intersects(arg1 : PathIterator, arg2 : number, arg3 : number, arg4 : number, arg5 : number) : boolean;
	static intersects(arg1 : PathIterator, arg2 : Rectangle2D) : boolean;
	writeObject(arg1 : ObjectOutputStream, arg2 : boolean) : void;
	readObject(arg1 : ObjectInputStream, arg2 : boolean) : void;
}


declare interface Path2D extends Shape, Cloneable {}

declare module Path2D {
	class Double {
		bounds2D : Rectangle2D;
		constructor();
		constructor(arg1 : number);
		constructor(arg1 : number, arg2 : number);
		constructor(arg1 : Shape);
		constructor(arg1 : Shape, arg2 : AffineTransform);
		writeObject(arg1 : ObjectOutputStream) : void;
		readObject(arg1 : ObjectInputStream) : void;
	}


	interface Double extends Path2D, Serializable {}

	module Double {
		class CopyIterator {
		}


		interface CopyIterator extends Path2D.Iterator {}		class TxIterator {
		}


		interface TxIterator extends Path2D.Iterator {}	}
	class Float {
		bounds2D : Rectangle2D;
		constructor();
		constructor(arg1 : number);
		constructor(arg1 : number, arg2 : number);
		constructor(arg1 : Shape);
		constructor(arg1 : Shape, arg2 : AffineTransform);
		moveTo(arg1 : number, arg2 : number) : void;
		lineTo(arg1 : number, arg2 : number) : void;
		quadTo(arg1 : number, arg2 : number, arg3 : number, arg4 : number) : void;
		curveTo(arg1 : number, arg2 : number, arg3 : number, arg4 : number, arg5 : number, arg6 : number) : void;
		writeObject(arg1 : ObjectOutputStream) : void;
		readObject(arg1 : ObjectInputStream) : void;
	}


	interface Float extends Path2D, Serializable {}

	module Float {
		class CopyIterator {
		}


		interface CopyIterator extends Path2D.Iterator {}		class TxIterator {
		}


		interface TxIterator extends Path2D.Iterator {}	}
	class Iterator {
		windingRule : number;
		done : boolean;
	}


	interface Iterator extends PathIterator {}}

export = Path2D
