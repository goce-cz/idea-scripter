import URL = require('nashorn/java/net/URL');
import ObjectOutputStream = require('nashorn/java/io/ObjectOutputStream');
import ObjectInputStream = require('nashorn/java/io/ObjectInputStream');
import StringBuffer = require('nashorn/java/lang/StringBuffer');
import Comparable = require('nashorn/java/lang/Comparable');
import Serializable = require('nashorn/java/io/Serializable');
import Object = require('nashorn/java/lang/Object');

declare class URI {
	scheme : string;
	absolute : boolean;
	opaque : boolean;
	rawSchemeSpecificPart : string;
	schemeSpecificPart : string;
	rawAuthority : string;
	authority : string;
	rawUserInfo : string;
	userInfo : string;
	host : string;
	port : number;
	rawPath : string;
	path : string;
	rawQuery : string;
	query : string;
	rawFragment : string;
	fragment : string;
	constructor(arg1 : string);
	constructor(arg1 : string, arg2 : string, arg3 : string, arg4 : number, arg5 : string, arg6 : string, arg7 : string);
	constructor(arg1 : string, arg2 : string, arg3 : string, arg4 : string, arg5 : string);
	constructor(arg1 : string, arg2 : string, arg3 : string, arg4 : string);
	constructor(arg1 : string, arg2 : string, arg3 : string);
	static create(arg1 : string) : URI;
	parseServerAuthority() : URI;
	normalize() : URI;
	resolve(arg1 : URI) : URI;
	resolve(arg1 : string) : URI;
	relativize(arg1 : URI) : URI;
	toURL() : URL;
	getScheme() : string;
	isAbsolute() : boolean;
	isOpaque() : boolean;
	getRawSchemeSpecificPart() : string;
	getSchemeSpecificPart() : string;
	getRawAuthority() : string;
	getAuthority() : string;
	getRawUserInfo() : string;
	getUserInfo() : string;
	getHost() : string;
	getPort() : number;
	getRawPath() : string;
	getPath() : string;
	getRawQuery() : string;
	getQuery() : string;
	getRawFragment() : string;
	getFragment() : string;
	toASCIIString() : string;
	writeObject(arg1 : ObjectOutputStream) : void;
	readObject(arg1 : ObjectInputStream) : void;
	static toLower(arg1 : string) : number;
	static toUpper(arg1 : string) : number;
	static equal(arg1 : string, arg2 : string) : boolean;
	static equalIgnoringCase(arg1 : string, arg2 : string) : boolean;
	static hash(arg1 : number, arg2 : string) : number;
	static normalizedHash(arg1 : number, arg2 : string) : number;
	static hashIgnoringCase(arg1 : number, arg2 : string) : number;
	static compare(arg1 : string, arg2 : string) : number;
	static compareIgnoringCase(arg1 : string, arg2 : string) : number;
	static checkPath(arg1 : string, arg2 : string, arg3 : string) : void;
	appendAuthority(arg1 : StringBuffer, arg2 : string, arg3 : string, arg4 : string, arg5 : number) : void;
	appendSchemeSpecificPart(arg1 : StringBuffer, arg2 : string, arg3 : string, arg4 : string, arg5 : string, arg6 : number, arg7 : string, arg8 : string) : void;
	appendFragment(arg1 : StringBuffer, arg2 : string) : void;
	toString(arg1 : string, arg2 : string, arg3 : string, arg4 : string, arg5 : string, arg6 : number, arg7 : string, arg8 : string, arg9 : string) : string;
	defineSchemeSpecificPart() : void;
	defineString() : void;
	static resolvePath(arg1 : string, arg2 : string, arg3 : boolean) : string;
	static resolve(arg1 : URI, arg2 : URI) : URI;
	static normalize(arg1 : URI) : URI;
	static relativize(arg1 : URI, arg2 : URI) : URI;
	static needsNormalization(arg1 : string) : number;
	static split(arg1 : string[], arg2 : number[]) : void;
	static join(arg1 : string[], arg2 : number[]) : number;
	static removeDots(arg1 : string[], arg2 : number[]) : void;
	static maybeAddLeadingDot(arg1 : string[], arg2 : number[]) : void;
	static normalize(arg1 : string) : string;
	static lowMask(arg1 : string) : number;
	static highMask(arg1 : string) : number;
	static lowMask(arg1 : string, arg2 : string) : number;
	static highMask(arg1 : string, arg2 : string) : number;
	static match(arg1 : string, arg2 : number, arg3 : number) : boolean;
	static appendEscape(arg1 : StringBuffer, arg2 : number) : void;
	static appendEncoded(arg1 : StringBuffer, arg2 : string) : void;
	static quote(arg1 : string, arg2 : number, arg3 : number) : string;
	static encode(arg1 : string) : string;
	static decode(arg1 : string) : number;
	static decode(arg1 : string, arg2 : string) : number;
	static decode(arg1 : string) : string;
}


declare interface URI extends Comparable<URI>, Serializable {}

declare module URI {
	class Parser extends Object {
		fail(arg1 : string) : void;
		fail(arg1 : string, arg2 : number) : void;
		failExpecting(arg1 : string, arg2 : number) : void;
		failExpecting(arg1 : string, arg2 : string, arg3 : number) : void;
		substring(arg1 : number, arg2 : number) : string;
		charAt(arg1 : number) : string;
		at(arg1 : number, arg2 : number, arg3 : string) : boolean;
		at(arg1 : number, arg2 : number, arg3 : string) : boolean;
		scan(arg1 : number, arg2 : number, arg3 : string) : number;
		scan(arg1 : number, arg2 : number, arg3 : string, arg4 : string) : number;
		scanEscape(arg1 : number, arg2 : number, arg3 : string) : number;
		scan(arg1 : number, arg2 : number, arg3 : number, arg4 : number) : number;
		checkChars(arg1 : number, arg2 : number, arg3 : number, arg4 : number, arg5 : string) : void;
		checkChar(arg1 : number, arg2 : number, arg3 : number, arg4 : string) : void;
		parse(arg1 : boolean) : void;
		parseHierarchical(arg1 : number, arg2 : number) : number;
		parseAuthority(arg1 : number, arg2 : number) : number;
		parseServer(arg1 : number, arg2 : number) : number;
		scanByte(arg1 : number, arg2 : number) : number;
		scanIPv4Address(arg1 : number, arg2 : number, arg3 : boolean) : number;
		takeIPv4Address(arg1 : number, arg2 : number, arg3 : string) : number;
		parseIPv4Address(arg1 : number, arg2 : number) : number;
		parseHostname(arg1 : number, arg2 : number) : number;
		parseIPv6Reference(arg1 : number, arg2 : number) : number;
		scanHexPost(arg1 : number, arg2 : number) : number;
		scanHexSeq(arg1 : number, arg2 : number) : number;
	}
}

export = URI
