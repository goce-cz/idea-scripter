import ThreadGroup = require('nashorn/java/lang/ThreadGroup');
import ClassLoader = require('nashorn/java/lang/ClassLoader');
import StackTraceElement = require('nashorn/java/lang/StackTraceElement');
import Map = require('nashorn/java/util/Map');
import Runnable = require('nashorn/java/lang/Runnable');
import Interruptible = require('nashorn/sun/nio/ch/Interruptible');
import AccessControlContext = require('nashorn/java/security/AccessControlContext');
import Throwable = require('nashorn/java/lang/Throwable');
import Object = require('nashorn/java/lang/Object');
import Class = require('nashorn/java/lang/Class');
import ReferenceQueue = require('nashorn/java/lang/ref/ReferenceQueue');
import ConcurrentMap = require('nashorn/java/util/concurrent/ConcurrentMap');
import WeakReference = require('nashorn/java/lang/ref/WeakReference');
import Enum = require('nashorn/java/lang/Enum');

declare class Thread {
	static MIN_PRIORITY : number;
	static NORM_PRIORITY : number;
	static MAX_PRIORITY : number;
	interrupted : boolean;
	alive : boolean;
	priority : number;
	name : string;
	threadGroup : ThreadGroup;
	daemon : boolean;
	contextClassLoader : ClassLoader;
	stackTrace : StackTraceElement[];
	static allStackTraces : Map<Thread, StackTraceElement[]>;
	id : number;
	state : Thread.State;
	static defaultUncaughtExceptionHandler : Thread.UncaughtExceptionHandler;
	uncaughtExceptionHandler : Thread.UncaughtExceptionHandler;
	constructor();
	constructor(arg1 : Runnable);
	constructor(arg1 : ThreadGroup, arg2 : Runnable);
	constructor(arg1 : string);
	constructor(arg1 : ThreadGroup, arg2 : string);
	constructor(arg1 : Runnable, arg2 : string);
	constructor(arg1 : ThreadGroup, arg2 : Runnable, arg3 : string);
	constructor(arg1 : ThreadGroup, arg2 : Runnable, arg3 : string, arg4 : number);
	static registerNatives() : void;
	static nextThreadNum() : number;
	static nextThreadID() : number;
	blockedOn(arg1 : Interruptible) : void;
	static currentThread() : Thread;
	static yield() : void;
	static sleep(arg1 : number) : void;
	static sleep(arg1 : number, arg2 : number) : void;
	init(arg1 : ThreadGroup, arg2 : Runnable, arg3 : string, arg4 : number) : void;
	init(arg1 : ThreadGroup, arg2 : Runnable, arg3 : string, arg4 : number, arg5 : AccessControlContext) : void;
	start() : void;
	start0() : void;
	exit() : void;
	stop() : void;
	stop(arg1 : Throwable) : void;
	interrupt() : void;
	static interrupted() : boolean;
	isInterrupted() : boolean;
	isInterrupted(arg1 : boolean) : boolean;
	destroy() : void;
	isAlive() : boolean;
	suspend() : void;
	resume() : void;
	setPriority(arg1 : number) : void;
	getPriority() : number;
	setName(arg1 : string) : void;
	getName() : string;
	getThreadGroup() : ThreadGroup;
	static activeCount() : number;
	static enumerate(arg1 : Thread[]) : number;
	countStackFrames() : number;
	join(arg1 : number) : void;
	join(arg1 : number, arg2 : number) : void;
	join() : void;
	static dumpStack() : void;
	setDaemon(arg1 : boolean) : void;
	isDaemon() : boolean;
	checkAccess() : void;
	getContextClassLoader() : ClassLoader;
	setContextClassLoader(arg1 : ClassLoader) : void;
	static holdsLock(arg1 : Object) : boolean;
	getStackTrace() : StackTraceElement[];
	static getAllStackTraces() : Map<Thread, StackTraceElement[]>;
	static isCCLOverridden(arg1 : Class<any>) : boolean;
	static auditSubclass(arg1 : Class<any>) : boolean;
	static dumpThreads(arg1 : Thread[]) : StackTraceElement[][];
	static getThreads() : Thread[];
	getId() : number;
	getState() : Thread.State;
	static setDefaultUncaughtExceptionHandler(arg1 : Thread.UncaughtExceptionHandler) : void;
	static getDefaultUncaughtExceptionHandler() : Thread.UncaughtExceptionHandler;
	getUncaughtExceptionHandler() : Thread.UncaughtExceptionHandler;
	setUncaughtExceptionHandler(arg1 : Thread.UncaughtExceptionHandler) : void;
	dispatchUncaughtException(arg1 : Throwable) : void;
	static processQueue(arg1 : ReferenceQueue<Class<any>>, arg2 : ConcurrentMap<WeakReference<Class<any>>, any>) : void;
	setPriority0(arg1 : number) : void;
	stop0(arg1 : Object) : void;
	suspend0() : void;
	resume0() : void;
	interrupt0() : void;
	setNativeName(arg1 : string) : void;
}


declare interface Thread extends Runnable {}

declare module Thread {
	class Caches extends Object {
	}
	class State {
		static NEW : Thread.State;
		static RUNNABLE : Thread.State;
		static BLOCKED : Thread.State;
		static WAITING : Thread.State;
		static TIMED_WAITING : Thread.State;
		static TERMINATED : Thread.State;
	}


	interface State extends Enum<Thread.State> {}	class UncaughtExceptionHandler_interface extends Object {
		uncaughtException(arg1 : Thread, arg2 : Throwable) : void;
	}


	type UncaughtExceptionHandler = UncaughtExceptionHandler_interface | ((arg1 : Thread, arg2 : Throwable)=>void);	class WeakClassKey {
	}


	interface WeakClassKey extends WeakReference<Class<any>> {}}

export = Thread
