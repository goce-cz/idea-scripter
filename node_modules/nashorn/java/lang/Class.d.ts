import ClassLoader = require('nashorn/java/lang/ClassLoader');
import TypeVariable = require('nashorn/java/lang/reflect/TypeVariable');
import Type = require('nashorn/java/lang/reflect/Type');
import Package = require('nashorn/java/lang/Package');
import Object = require('nashorn/java/lang/Object');
import Method = require('nashorn/java/lang/reflect/Method');
import Constructor = require('nashorn/java/lang/reflect/Constructor');
import Field = require('nashorn/java/lang/reflect/Field');
import ProtectionDomain = require('nashorn/java/security/ProtectionDomain');
import Annotation = require('nashorn/java/lang/annotation/Annotation');
import AnnotatedType = require('nashorn/java/lang/reflect/AnnotatedType');
import InputStream = require('nashorn/java/io/InputStream');
import URL = require('nashorn/java/net/URL');
import SoftReference = require('nashorn/java/lang/ref/SoftReference');
import GenericsFactory = require('nashorn/sun/reflect/generics/factory/GenericsFactory');
import ClassRepository = require('nashorn/sun/reflect/generics/repository/ClassRepository');
import Executable = require('nashorn/java/lang/reflect/Executable');
import ConstantPool = require('nashorn/sun/reflect/ConstantPool');
import Set = require('nashorn/java/util/Set');
import Collection = require('nashorn/java/util/Collection');
import ReflectionFactory = require('nashorn/sun/reflect/ReflectionFactory');
import Map = require('nashorn/java/util/Map');
import AnnotationType = require('nashorn/sun/reflect/annotation/AnnotationType');
import Serializable = require('nashorn/java/io/Serializable');
import GenericDeclaration = require('nashorn/java/lang/reflect/GenericDeclaration');
import AnnotatedElement = require('nashorn/java/lang/reflect/AnnotatedElement');

declare class Class<T> {
	interface : boolean;
	array : boolean;
	primitive : boolean;
	annotation : boolean;
	synthetic : boolean;
	name : string;
	classLoader : ClassLoader;
	typeParameters : TypeVariable<Class<T>>[];
	superclass : Class<any>;
	genericSuperclass : Type;
	package : Package;
	interfaces : Class<any>[];
	genericInterfaces : Type[];
	componentType : Class<any>;
	modifiers : number;
	signers : Object[];
	enclosingMethod : Method;
	enclosingConstructor : Constructor<any>;
	declaringClass : Class<any>;
	enclosingClass : Class<any>;
	simpleName : string;
	typeName : string;
	canonicalName : string;
	anonymousClass : boolean;
	localClass : boolean;
	memberClass : boolean;
	classes : Class<any>[];
	fields : Field[];
	methods : Method[];
	constructors : Constructor<any>[];
	declaredClasses : Class<any>[];
	declaredFields : Field[];
	declaredMethods : Method[];
	declaredConstructors : Constructor<any>[];
	protectionDomain : ProtectionDomain;
	enumConstants : T[];
	annotations : Annotation[];
	declaredAnnotations : Annotation[];
	annotatedSuperclass : AnnotatedType;
	annotatedInterfaces : AnnotatedType[];
	static registerNatives() : void;
	toGenericString() : string;
	static forName(arg1 : string) : Class<any>;
	static forName(arg1 : string, arg2 : boolean, arg3 : ClassLoader) : Class<any>;
	static forName0(arg1 : string, arg2 : boolean, arg3 : ClassLoader, arg4 : Class<any>) : Class<any>;
	newInstance() : T;
	isInstance(arg1 : Object) : boolean;
	isAssignableFrom(arg1 : Class<any>) : boolean;
	isInterface() : boolean;
	isArray() : boolean;
	isPrimitive() : boolean;
	isAnnotation() : boolean;
	isSynthetic() : boolean;
	getName() : string;
	getName0() : string;
	getClassLoader() : ClassLoader;
	getClassLoader0() : ClassLoader;
	getSuperclass() : Class<any>;
	getGenericSuperclass() : Type;
	getPackage() : Package;
	getInterfaces() : Class<any>[];
	getInterfaces0() : Class<any>[];
	getGenericInterfaces() : Type[];
	getComponentType() : Class<any>;
	getModifiers() : number;
	getSigners() : Object[];
	setSigners(arg1 : Object[]) : void;
	getEnclosingMethod() : Method;
	getEnclosingMethod0() : Object[];
	getEnclosingMethodInfo() : Class.EnclosingMethodInfo;
	static toClass(arg1 : Type) : Class<any>;
	getEnclosingConstructor() : Constructor<any>;
	getDeclaringClass() : Class<any>;
	getDeclaringClass0() : Class<any>;
	getEnclosingClass() : Class<any>;
	getSimpleName() : string;
	static isAsciiDigit(arg1 : string) : boolean;
	getCanonicalName() : string;
	isAnonymousClass() : boolean;
	isLocalClass() : boolean;
	isMemberClass() : boolean;
	getSimpleBinaryName() : string;
	isLocalOrAnonymousClass() : boolean;
	getClasses() : Class<any>[];
	getFields() : Field[];
	getMethods() : Method[];
	getConstructors() : Constructor<any>[];
	getField(arg1 : string) : Field;
	getMethod(arg1 : string, arg2 : Class<any>[]) : Method;
	getConstructor(arg1 : Class<any>[]) : Constructor<T>;
	getDeclaredClasses() : Class<any>[];
	getDeclaredFields() : Field[];
	getDeclaredMethods() : Method[];
	getDeclaredConstructors() : Constructor<any>[];
	getDeclaredField(arg1 : string) : Field;
	getDeclaredMethod(arg1 : string, arg2 : Class<any>[]) : Method;
	getDeclaredConstructor(arg1 : Class<any>[]) : Constructor<T>;
	getResourceAsStream(arg1 : string) : InputStream;
	getResource(arg1 : string) : URL;
	getProtectionDomain() : ProtectionDomain;
	getProtectionDomain0() : ProtectionDomain;
	static getPrimitiveClass(arg1 : string) : Class<any>;
	checkMemberAccess(arg1 : number, arg2 : Class<any>, arg3 : boolean) : void;
	checkPackageAccess(arg1 : ClassLoader, arg2 : boolean) : void;
	resolveName(arg1 : string) : string;
	reflectionData() : Class.ReflectionData<T>;
	newReflectionData(arg1 : SoftReference<Class.ReflectionData<T>>, arg2 : number) : Class.ReflectionData<T>;
	getGenericSignature0() : string;
	getFactory() : GenericsFactory;
	getGenericInfo() : ClassRepository;
	getRawAnnotations() : number[];
	getRawTypeAnnotations() : number[];
	static getExecutableTypeAnnotationBytes(arg1 : Executable) : number[];
	getConstantPool() : ConstantPool;
	privateGetDeclaredFields(arg1 : boolean) : Field[];
	privateGetPublicFields(arg1 : Set<Class<any>>) : Field[];
	static addAll(arg1 : Collection<Field>, arg2 : Field[]) : void;
	privateGetDeclaredConstructors(arg1 : boolean) : Constructor<T>[];
	privateGetDeclaredMethods(arg1 : boolean) : Method[];
	privateGetPublicMethods() : Method[];
	static searchFields(arg1 : Field[], arg2 : string) : Field;
	getField0(arg1 : string) : Field;
	static searchMethods(arg1 : Method[], arg2 : string, arg3 : Class<any>[]) : Method;
	getMethod0(arg1 : string, arg2 : Class<any>[], arg3 : boolean) : Method;
	privateGetMethodRecursive(arg1 : string, arg2 : Class<any>[], arg3 : boolean, arg4 : Class.MethodArray) : Method;
	getConstructor0(arg1 : Class<any>[], arg2 : number) : Constructor<T>;
	static arrayContentsEq(arg1 : Object[], arg2 : Object[]) : boolean;
	static copyFields(arg1 : Field[]) : Field[];
	static copyMethods(arg1 : Method[]) : Method[];
	static copyConstructors<U>(arg1 : Constructor<U>[]) : Constructor<U>[];
	getDeclaredFields0(arg1 : boolean) : Field[];
	getDeclaredMethods0(arg1 : boolean) : Method[];
	getDeclaredConstructors0(arg1 : boolean) : Constructor<T>[];
	getDeclaredClasses0() : Class<any>[];
	static argumentTypesToString(arg1 : Class<any>[]) : string;
	desiredAssertionStatus() : boolean;
	static desiredAssertionStatus0(arg1 : Class<any>) : boolean;
	isEnum() : boolean;
	static getReflectionFactory() : ReflectionFactory;
	static checkInitted() : void;
	getEnumConstants() : T[];
	getEnumConstantsShared() : T[];
	enumConstantDirectory() : Map<string, T>;
	cast(arg1 : Object) : T;
	cannotCastMsg(arg1 : Object) : string;
	asSubclass<U>(arg1 : Class<U>) : Class<U>;
	annotationData() : Class.AnnotationData;
	createAnnotationData(arg1 : number) : Class.AnnotationData;
	casAnnotationType(arg1 : AnnotationType, arg2 : AnnotationType) : boolean;
	getAnnotationType() : AnnotationType;
	getDeclaredAnnotationMap() : Map<Class<Annotation>, Annotation>;
	getAnnotatedSuperclass() : AnnotatedType;
	getAnnotatedInterfaces() : AnnotatedType[];
}


declare interface Class<T> extends Serializable, GenericDeclaration, Type, AnnotatedElement {}

declare module Class {
	class AnnotationData extends Object {
	}
	class Atomic extends Object {
		static objectFieldOffset(arg1 : Field[], arg2 : string) : number;
		static casReflectionData<T>(arg1 : Class<any>, arg2 : SoftReference<Class.ReflectionData<T>>, arg3 : SoftReference<Class.ReflectionData<T>>) : boolean;
		static casAnnotationType<T>(arg1 : Class<any>, arg2 : AnnotationType, arg3 : AnnotationType) : boolean;
		static casAnnotationData<T>(arg1 : Class<any>, arg2 : Class.AnnotationData, arg3 : Class.AnnotationData) : boolean;
	}
	class EnclosingMethodInfo extends Object {
		isPartial() : boolean;
		isConstructor() : boolean;
		isMethod() : boolean;
		getEnclosingClass() : Class<any>;
		getName() : string;
		getDescriptor() : string;
	}
	class MethodArray extends Object {
		hasDefaults() : boolean;
		add(arg1 : Method) : void;
		addAll(arg1 : Method[]) : void;
		addAll(arg1 : Class.MethodArray) : void;
		addIfNotPresent(arg1 : Method) : void;
		addAllIfNotPresent(arg1 : Class.MethodArray) : void;
		addInterfaceMethods(arg1 : Method[]) : void;
		length() : number;
		get(arg1 : number) : Method;
		getFirst() : Method;
		removeByNameAndDescriptor(arg1 : Method) : void;
		remove(arg1 : number) : void;
		matchesNameAndDescriptor(arg1 : Method, arg2 : Method) : boolean;
		compactAndTrim() : void;
		removeLessSpecifics() : void;
		getArray() : Method[];
		static hasMoreSpecificClass(arg1 : Method, arg2 : Method) : boolean;
	}
	class ReflectionData<T> extends Object {
	}
}

export = Class
