import ObjectStreamField = require('nashorn/java/io/ObjectStreamField');
import Class = require('nashorn/java/lang/Class');
import ClassNotFoundException = require('nashorn/java/lang/ClassNotFoundException');
import ObjectInputStream = require('nashorn/java/io/ObjectInputStream');
import ObjectOutputStream = require('nashorn/java/io/ObjectOutputStream');
import Object = require('nashorn/java/lang/Object');
import Constructor = require('nashorn/java/lang/reflect/Constructor');
import Method = require('nashorn/java/lang/reflect/Method');
import Throwable = require('nashorn/java/lang/Throwable');
import ReferenceQueue = require('nashorn/java/lang/ref/ReferenceQueue');
import ConcurrentMap = require('nashorn/java/util/concurrent/ConcurrentMap');
import WeakReference = require('nashorn/java/lang/ref/WeakReference');
import Serializable = require('nashorn/java/io/Serializable');
import Thread = require('nashorn/java/lang/Thread');
import InvalidClassException = require('nashorn/java/io/InvalidClassException');
import Member = require('nashorn/java/lang/reflect/Member');
import Field = require('nashorn/java/lang/reflect/Field');

declare class ObjectStreamClass {
	static NO_FIELDS : ObjectStreamField[];
	name : string;
	serialVersionUID : number;
	fields : ObjectStreamField[];
	static initNative() : void;
	static lookup(arg1 : Class<any>) : ObjectStreamClass;
	static lookupAny(arg1 : Class<any>) : ObjectStreamClass;
	getName() : string;
	getSerialVersionUID() : number;
	forClass() : Class<any>;
	getFields() : ObjectStreamField[];
	getField(arg1 : string) : ObjectStreamField;
	static lookup(arg1 : Class<any>, arg2 : boolean) : ObjectStreamClass;
	initProxy(arg1 : Class<any>, arg2 : ClassNotFoundException, arg3 : ObjectStreamClass) : void;
	initNonProxy(arg1 : ObjectStreamClass, arg2 : Class<any>, arg3 : ClassNotFoundException, arg4 : ObjectStreamClass) : void;
	readNonProxy(arg1 : ObjectInputStream) : void;
	writeNonProxy(arg1 : ObjectOutputStream) : void;
	getResolveException() : ClassNotFoundException;
	checkDeserialize() : void;
	checkSerialize() : void;
	checkDefaultSerialize() : void;
	getSuperDesc() : ObjectStreamClass;
	getLocalDesc() : ObjectStreamClass;
	getFields(arg1 : boolean) : ObjectStreamField[];
	getField(arg1 : string, arg2 : Class<any>) : ObjectStreamField;
	isProxy() : boolean;
	isEnum() : boolean;
	isExternalizable() : boolean;
	isSerializable() : boolean;
	hasBlockExternalData() : boolean;
	hasWriteObjectData() : boolean;
	isInstantiable() : boolean;
	hasWriteObjectMethod() : boolean;
	hasReadObjectMethod() : boolean;
	hasReadObjectNoDataMethod() : boolean;
	hasWriteReplaceMethod() : boolean;
	hasReadResolveMethod() : boolean;
	newInstance() : Object;
	invokeWriteObject(arg1 : Object, arg2 : ObjectOutputStream) : void;
	invokeReadObject(arg1 : Object, arg2 : ObjectInputStream) : void;
	invokeReadObjectNoData(arg1 : Object) : void;
	invokeWriteReplace(arg1 : Object) : Object;
	invokeReadResolve(arg1 : Object) : Object;
	getClassDataLayout() : ObjectStreamClass.ClassDataSlot[];
	getClassDataLayout0() : ObjectStreamClass.ClassDataSlot[];
	getPrimDataSize() : number;
	getNumObjFields() : number;
	getPrimFieldValues(arg1 : Object, arg2 : number[]) : void;
	setPrimFieldValues(arg1 : Object, arg2 : number[]) : void;
	getObjFieldValues(arg1 : Object, arg2 : Object[]) : void;
	setObjFieldValues(arg1 : Object, arg2 : Object[]) : void;
	computeFieldOffsets() : void;
	getVariantFor(arg1 : Class<any>) : ObjectStreamClass;
	static getExternalizableConstructor(arg1 : Class<any>) : Constructor<any>;
	static getSerializableConstructor(arg1 : Class<any>) : Constructor<any>;
	static getInheritableMethod(arg1 : Class<any>, arg2 : string, arg3 : Class<any>[], arg4 : Class<any>) : Method;
	static getPrivateMethod(arg1 : Class<any>, arg2 : string, arg3 : Class<any>[], arg4 : Class<any>) : Method;
	static packageEquals(arg1 : Class<any>, arg2 : Class<any>) : boolean;
	static getPackageName(arg1 : Class<any>) : string;
	static classNamesEqual(arg1 : string, arg2 : string) : boolean;
	static getClassSignature(arg1 : Class<any>) : string;
	static getMethodSignature(arg1 : Class<any>[], arg2 : Class<any>) : string;
	static throwMiscException(arg1 : Throwable) : void;
	static getSerialFields(arg1 : Class<any>) : ObjectStreamField[];
	static getDeclaredSerialFields(arg1 : Class<any>) : ObjectStreamField[];
	static getDefaultSerialFields(arg1 : Class<any>) : ObjectStreamField[];
	static getDeclaredSUID(arg1 : Class<any>) : number;
	static computeDefaultSUID(arg1 : Class<any>) : number;
	static hasStaticInitializer(arg1 : Class<any>) : boolean;
	static getReflector(arg1 : ObjectStreamField[], arg2 : ObjectStreamClass) : ObjectStreamClass.FieldReflector;
	static matchFields(arg1 : ObjectStreamField[], arg2 : ObjectStreamClass) : ObjectStreamField[];
	static processQueue(arg1 : ReferenceQueue<Class<any>>, arg2 : ConcurrentMap<WeakReference<Class<any>>, any>) : void;
}


declare interface ObjectStreamClass extends Serializable {}

declare module ObjectStreamClass {
	class Caches extends Object {
	}
	class ClassDataSlot extends Object {
	}
	class EntryFuture extends Object {
		set(arg1 : Object) : boolean;
		get() : Object;
		getOwner() : Thread;
	}
	class ExceptionInfo extends Object {
		newInvalidClassException() : InvalidClassException;
	}
	class FieldReflector extends Object {
		getFields() : ObjectStreamField[];
		getPrimFieldValues(arg1 : Object, arg2 : number[]) : void;
		setPrimFieldValues(arg1 : Object, arg2 : number[]) : void;
		getObjFieldValues(arg1 : Object, arg2 : Object[]) : void;
		setObjFieldValues(arg1 : Object, arg2 : Object[]) : void;
	}
	class FieldReflectorKey {
	}


	interface FieldReflectorKey extends WeakReference<Class<any>> {}	class MemberSignature extends Object {
		member : Member;
		name : string;
		signature : string;
		constructor(arg1 : Field);
		constructor(arg1 : Constructor<any>);
		constructor(arg1 : Method);
	}
	class WeakClassKey {
	}


	interface WeakClassKey extends WeakReference<Class<any>> {}}

export = ObjectStreamClass
