import CharSequence = require('nashorn/java/lang/CharSequence');
import Matcher = require('nashorn/java/util/regex/Matcher');
import ObjectInputStream = require('nashorn/java/io/ObjectInputStream');
import StringBuilder = require('nashorn/java/lang/StringBuilder');
import Map = require('nashorn/java/util/Map');
import PatternSyntaxException = require('nashorn/java/util/regex/PatternSyntaxException');
import Predicate = require('nashorn/java/util/function/Predicate');
import Stream = require('nashorn/java/util/stream/Stream');
import Serializable = require('nashorn/java/io/Serializable');
import Object = require('nashorn/java/lang/Object');
import Cloneable = require('nashorn/java/lang/Cloneable');

declare class Pattern {
	static UNIX_LINES : number;
	static CASE_INSENSITIVE : number;
	static COMMENTS : number;
	static MULTILINE : number;
	static LITERAL : number;
	static DOTALL : number;
	static UNICODE_CASE : number;
	static CANON_EQ : number;
	static UNICODE_CHARACTER_CLASS : number;
	static compile(arg1 : string) : Pattern;
	static compile(arg1 : string, arg2 : number) : Pattern;
	pattern() : string;
	matcher(arg1 : CharSequence) : Matcher;
	flags() : number;
	static matches(arg1 : string, arg2 : CharSequence) : boolean;
	split(arg1 : CharSequence, arg2 : number) : string[];
	split(arg1 : CharSequence) : string[];
	static quote(arg1 : string) : string;
	readObject(arg1 : ObjectInputStream) : void;
	normalize() : void;
	normalizeCharClass(arg1 : StringBuilder, arg2 : number) : number;
	produceEquivalentAlternation(arg1 : string) : string;
	producePermutations(arg1 : string) : string[];
	getClass(arg1 : number) : number;
	composeOneStep(arg1 : string) : string;
	RemoveQEQuoting() : void;
	compile() : void;
	namedGroups() : Map<string, number>;
	static printObjectTree(arg1 : Pattern.Node) : void;
	has(arg1 : number) : boolean;
	accept(arg1 : number, arg2 : string) : void;
	mark(arg1 : number) : void;
	peek() : number;
	read() : number;
	readEscaped() : number;
	next() : number;
	nextEscaped() : number;
	peekPastWhitespace(arg1 : number) : number;
	parsePastWhitespace(arg1 : number) : number;
	parsePastLine() : number;
	peekPastLine() : number;
	isLineSeparator(arg1 : number) : boolean;
	skip() : number;
	unread() : void;
	error(arg1 : string) : PatternSyntaxException;
	findSupplementary(arg1 : number, arg2 : number) : boolean;
	static isSupplementary(arg1 : number) : boolean;
	expr(arg1 : Pattern.Node) : Pattern.Node;
	sequence(arg1 : Pattern.Node) : Pattern.Node;
	atom() : Pattern.Node;
	append(arg1 : number, arg2 : number) : void;
	ref(arg1 : number) : Pattern.Node;
	escape(arg1 : boolean, arg2 : boolean, arg3 : boolean) : number;
	clazz(arg1 : boolean) : Pattern.CharProperty;
	bitsOrSingle(arg1 : Pattern.BitClass, arg2 : number) : Pattern.CharProperty;
	range(arg1 : Pattern.BitClass) : Pattern.CharProperty;
	family(arg1 : boolean, arg2 : boolean) : Pattern.CharProperty;
	unicodeScriptPropertyFor(arg1 : string) : Pattern.CharProperty;
	unicodeBlockPropertyFor(arg1 : string) : Pattern.CharProperty;
	charPropertyNodeFor(arg1 : string) : Pattern.CharProperty;
	groupname(arg1 : number) : string;
	group0() : Pattern.Node;
	createGroup(arg1 : boolean) : Pattern.Node;
	addFlag() : void;
	subFlag() : void;
	closure(arg1 : Pattern.Node) : Pattern.Node;
	c() : number;
	o() : number;
	x() : number;
	cursor() : number;
	setcursor(arg1 : number) : void;
	uxxxx() : number;
	u() : number;
	static countChars(arg1 : CharSequence, arg2 : number, arg3 : number) : number;
	static countCodePoints(arg1 : CharSequence) : number;
	newSingle(arg1 : number) : Pattern.CharProperty;
	newSlice(arg1 : number[], arg2 : number, arg3 : boolean) : Pattern.Node;
	static inRange(arg1 : number, arg2 : number, arg3 : number) : boolean;
	static rangeFor(arg1 : number, arg2 : number) : Pattern.CharProperty;
	caseInsensitiveRangeFor(arg1 : number, arg2 : number) : Pattern.CharProperty;
	static union(arg1 : Pattern.CharProperty, arg2 : Pattern.CharProperty) : Pattern.CharProperty;
	static intersection(arg1 : Pattern.CharProperty, arg2 : Pattern.CharProperty) : Pattern.CharProperty;
	static setDifference(arg1 : Pattern.CharProperty, arg2 : Pattern.CharProperty) : Pattern.CharProperty;
	static hasBaseCharacter(arg1 : Matcher, arg2 : number, arg3 : CharSequence) : boolean;
	asPredicate() : Predicate<string>;
	splitAsStream(arg1 : CharSequence) : Stream<string>;
}


declare interface Pattern extends Serializable {}

declare module Pattern {
	class All {
	}


	interface All extends Pattern.CharProperty {}	class BackRef {
	}


	interface BackRef extends Pattern.Node {}	class Begin {
	}


	interface Begin extends Pattern.Node {}	class Behind {
	}


	interface Behind extends Pattern.Node {}	class BehindS {
	}


	interface BehindS extends Pattern.Behind {}	class BitClass {
		add(arg1 : number, arg2 : number) : Pattern.BitClass;
	}


	interface BitClass extends Pattern.BmpCharProperty {}	class Block {
	}


	interface Block extends Pattern.CharProperty {}	class BmpCharProperty {
	}


	interface BmpCharProperty extends Pattern.CharProperty {}	class BnM {
		static optimize(arg1 : Pattern.Node) : Pattern.Node;
	}


	interface BnM extends Pattern.Node {}	class BnMS {
	}


	interface BnMS extends Pattern.BnM {}	class Bound {
		isWord(arg1 : number) : boolean;
		check(arg1 : Matcher, arg2 : number, arg3 : CharSequence) : number;
	}


	interface Bound extends Pattern.Node {}	class Branch {
		add(arg1 : Pattern.Node) : void;
	}


	interface Branch extends Pattern.Node {}	class BranchConn {
	}


	interface BranchConn extends Pattern.Node {}	class CIBackRef {
	}


	interface CIBackRef extends Pattern.Node {}	class Caret {
	}


	interface Caret extends Pattern.Node {}	class Category {
	}


	interface Category extends Pattern.CharProperty {}	class CharProperty {
		isSatisfiedBy(arg1 : number) : boolean;
		complement() : Pattern.CharProperty;
	}


	interface CharProperty extends Pattern.Node {}	class CharPropertyNames extends Object {
		static charPropertyFor(arg1 : string) : Pattern.CharProperty;
		static defCategory(arg1 : string, arg2 : number) : void;
		static defRange(arg1 : string, arg2 : number, arg3 : number) : void;
		static defCtype(arg1 : string, arg2 : number) : void;
		static defClone(arg1 : string, arg2 : Pattern.CharPropertyNames.CloneableProperty) : void;
	}


	module CharPropertyNames {
		class CharPropertyFactory extends Object {
			make() : Pattern.CharProperty;
		}
		class CloneableProperty {
		}


		interface CloneableProperty extends Pattern.CharProperty, Cloneable {}	}
	class Conditional {
	}


	interface Conditional extends Pattern.Node {}	class Ctype {
	}


	interface Ctype extends Pattern.BmpCharProperty {}	class Curly {
		match0(arg1 : Matcher, arg2 : number, arg3 : number, arg4 : CharSequence) : boolean;
		match1(arg1 : Matcher, arg2 : number, arg3 : number, arg4 : CharSequence) : boolean;
		match2(arg1 : Matcher, arg2 : number, arg3 : number, arg4 : CharSequence) : boolean;
	}


	interface Curly extends Pattern.Node {}	class Dollar {
	}


	interface Dollar extends Pattern.Node {}	class Dot {
	}


	interface Dot extends Pattern.CharProperty {}	class End {
	}


	interface End extends Pattern.Node {}	class First {
	}


	interface First extends Pattern.Node {}	class GroupCurly {
		match0(arg1 : Matcher, arg2 : number, arg3 : number, arg4 : CharSequence) : boolean;
		match1(arg1 : Matcher, arg2 : number, arg3 : number, arg4 : CharSequence) : boolean;
		match2(arg1 : Matcher, arg2 : number, arg3 : number, arg4 : CharSequence) : boolean;
	}


	interface GroupCurly extends Pattern.Node {}	class GroupHead {
		matchRef(arg1 : Matcher, arg2 : number, arg3 : CharSequence) : boolean;
	}


	interface GroupHead extends Pattern.Node {}	class GroupRef {
	}


	interface GroupRef extends Pattern.Node {}	class GroupTail {
	}


	interface GroupTail extends Pattern.Node {}	class HorizWS {
	}


	interface HorizWS extends Pattern.BmpCharProperty {}	class LastMatch {
	}


	interface LastMatch extends Pattern.Node {}	class LastNode {
	}


	interface LastNode extends Pattern.Node {}	class LazyLoop {
	}


	interface LazyLoop extends Pattern.Loop {}	class LineEnding {
	}


	interface LineEnding extends Pattern.Node {}	class Loop {
		matchInit(arg1 : Matcher, arg2 : number, arg3 : CharSequence) : boolean;
	}


	interface Loop extends Pattern.Node {}	class Neg {
	}


	interface Neg extends Pattern.Node {}	class Node extends Object {
		match(arg1 : Matcher, arg2 : number, arg3 : CharSequence) : boolean;
		study(arg1 : Pattern.TreeInfo) : boolean;
	}
	class NotBehind {
	}


	interface NotBehind extends Pattern.Node {}	class NotBehindS {
	}


	interface NotBehindS extends Pattern.NotBehind {}	class Pos {
	}


	interface Pos extends Pattern.Node {}	class Prolog {
	}


	interface Prolog extends Pattern.Node {}	class Ques {
	}


	interface Ques extends Pattern.Node {}	class Script {
	}


	interface Script extends Pattern.CharProperty {}	class Single {
	}


	interface Single extends Pattern.BmpCharProperty {}	class SingleI {
	}


	interface SingleI extends Pattern.BmpCharProperty {}	class SingleS {
	}


	interface SingleS extends Pattern.CharProperty {}	class SingleU {
	}


	interface SingleU extends Pattern.CharProperty {}	class Slice {
	}


	interface Slice extends Pattern.SliceNode {}	class SliceI {
	}


	interface SliceI extends Pattern.SliceNode {}	class SliceIS {
		toLower(arg1 : number) : number;
	}


	interface SliceIS extends Pattern.SliceNode {}	class SliceNode {
	}


	interface SliceNode extends Pattern.Node {}	class SliceS {
	}


	interface SliceS extends Pattern.SliceNode {}	class SliceU {
	}


	interface SliceU extends Pattern.SliceNode {}	class SliceUS {
	}


	interface SliceUS extends Pattern.SliceIS {}	class Start {
	}


	interface Start extends Pattern.Node {}	class StartS {
	}


	interface StartS extends Pattern.Start {}	class TreeInfo extends Object {
		reset() : void;
	}
	class UnixCaret {
	}


	interface UnixCaret extends Pattern.Node {}	class UnixDollar {
	}


	interface UnixDollar extends Pattern.Node {}	class UnixDot {
	}


	interface UnixDot extends Pattern.CharProperty {}	class Utype {
	}


	interface Utype extends Pattern.CharProperty {}	class VertWS {
	}


	interface VertWS extends Pattern.BmpCharProperty {}}

export = Pattern
