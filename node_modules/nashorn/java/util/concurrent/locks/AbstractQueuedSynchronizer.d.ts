import Thread = require('nashorn/java/lang/Thread');
import Collection = require('nashorn/java/util/Collection');
import AbstractOwnableSynchronizer = require('nashorn/java/util/concurrent/locks/AbstractOwnableSynchronizer');
import Serializable = require('nashorn/java/io/Serializable');
import Condition = require('nashorn/java/util/concurrent/locks/Condition');
import Object = require('nashorn/java/lang/Object');

declare class AbstractQueuedSynchronizer {
	firstQueuedThread : Thread;
	queueLength : number;
	queuedThreads : Collection<Thread>;
	exclusiveQueuedThreads : Collection<Thread>;
	sharedQueuedThreads : Collection<Thread>;
	getState() : number;
	setState(arg1 : number) : void;
	compareAndSetState(arg1 : number, arg2 : number) : boolean;
	enq(arg1 : AbstractQueuedSynchronizer.Node) : AbstractQueuedSynchronizer.Node;
	addWaiter(arg1 : AbstractQueuedSynchronizer.Node) : AbstractQueuedSynchronizer.Node;
	setHead(arg1 : AbstractQueuedSynchronizer.Node) : void;
	unparkSuccessor(arg1 : AbstractQueuedSynchronizer.Node) : void;
	doReleaseShared() : void;
	setHeadAndPropagate(arg1 : AbstractQueuedSynchronizer.Node, arg2 : number) : void;
	cancelAcquire(arg1 : AbstractQueuedSynchronizer.Node) : void;
	static shouldParkAfterFailedAcquire(arg1 : AbstractQueuedSynchronizer.Node, arg2 : AbstractQueuedSynchronizer.Node) : boolean;
	static selfInterrupt() : void;
	parkAndCheckInterrupt() : boolean;
	acquireQueued(arg1 : AbstractQueuedSynchronizer.Node, arg2 : number) : boolean;
	doAcquireInterruptibly(arg1 : number) : void;
	doAcquireNanos(arg1 : number, arg2 : number) : boolean;
	doAcquireShared(arg1 : number) : void;
	doAcquireSharedInterruptibly(arg1 : number) : void;
	doAcquireSharedNanos(arg1 : number, arg2 : number) : boolean;
	tryAcquire(arg1 : number) : boolean;
	tryRelease(arg1 : number) : boolean;
	tryAcquireShared(arg1 : number) : number;
	tryReleaseShared(arg1 : number) : boolean;
	isHeldExclusively() : boolean;
	acquire(arg1 : number) : void;
	acquireInterruptibly(arg1 : number) : void;
	tryAcquireNanos(arg1 : number, arg2 : number) : boolean;
	release(arg1 : number) : boolean;
	acquireShared(arg1 : number) : void;
	acquireSharedInterruptibly(arg1 : number) : void;
	tryAcquireSharedNanos(arg1 : number, arg2 : number) : boolean;
	releaseShared(arg1 : number) : boolean;
	hasQueuedThreads() : boolean;
	hasContended() : boolean;
	getFirstQueuedThread() : Thread;
	fullGetFirstQueuedThread() : Thread;
	isQueued(arg1 : Thread) : boolean;
	apparentlyFirstQueuedIsExclusive() : boolean;
	hasQueuedPredecessors() : boolean;
	getQueueLength() : number;
	getQueuedThreads() : Collection<Thread>;
	getExclusiveQueuedThreads() : Collection<Thread>;
	getSharedQueuedThreads() : Collection<Thread>;
	isOnSyncQueue(arg1 : AbstractQueuedSynchronizer.Node) : boolean;
	findNodeFromTail(arg1 : AbstractQueuedSynchronizer.Node) : boolean;
	transferForSignal(arg1 : AbstractQueuedSynchronizer.Node) : boolean;
	transferAfterCancelledWait(arg1 : AbstractQueuedSynchronizer.Node) : boolean;
	fullyRelease(arg1 : AbstractQueuedSynchronizer.Node) : number;
	owns(arg1 : AbstractQueuedSynchronizer.ConditionObject) : boolean;
	hasWaiters(arg1 : AbstractQueuedSynchronizer.ConditionObject) : boolean;
	getWaitQueueLength(arg1 : AbstractQueuedSynchronizer.ConditionObject) : number;
	getWaitingThreads(arg1 : AbstractQueuedSynchronizer.ConditionObject) : Collection<Thread>;
	compareAndSetHead(arg1 : AbstractQueuedSynchronizer.Node) : boolean;
	compareAndSetTail(arg1 : AbstractQueuedSynchronizer.Node, arg2 : AbstractQueuedSynchronizer.Node) : boolean;
	static compareAndSetWaitStatus(arg1 : AbstractQueuedSynchronizer.Node, arg2 : number, arg3 : number) : boolean;
	static compareAndSetNext(arg1 : AbstractQueuedSynchronizer.Node, arg2 : AbstractQueuedSynchronizer.Node, arg3 : AbstractQueuedSynchronizer.Node) : boolean;
}


declare interface AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer, Serializable {}

declare module AbstractQueuedSynchronizer {
	class ConditionObject {
		constructor();
		addConditionWaiter() : AbstractQueuedSynchronizer.Node;
		doSignal(arg1 : AbstractQueuedSynchronizer.Node) : void;
		doSignalAll(arg1 : AbstractQueuedSynchronizer.Node) : void;
		unlinkCancelledWaiters() : void;
		checkInterruptWhileWaiting(arg1 : AbstractQueuedSynchronizer.Node) : number;
		reportInterruptAfterWait(arg1 : number) : void;
		isOwnedBy(arg1 : AbstractQueuedSynchronizer) : boolean;
		hasWaiters() : boolean;
		getWaitQueueLength() : number;
		getWaitingThreads() : Collection<Thread>;
	}


	interface ConditionObject extends Condition, Serializable {}	class Node extends Object {
		isShared() : boolean;
		predecessor() : AbstractQueuedSynchronizer.Node;
	}
}

export = AbstractQueuedSynchronizer
