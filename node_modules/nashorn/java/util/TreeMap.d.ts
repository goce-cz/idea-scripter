import Comparator = require('nashorn/java/util/Comparator');
import Map = require('nashorn/java/util/Map');
import SortedMap = require('nashorn/java/util/SortedMap');
import Object = require('nashorn/java/lang/Object');
import Iterator = require('nashorn/java/util/Iterator');
import ObjectOutputStream = require('nashorn/java/io/ObjectOutputStream');
import ObjectInputStream = require('nashorn/java/io/ObjectInputStream');
import SortedSet = require('nashorn/java/util/SortedSet');
import NavigableMap = require('nashorn/java/util/NavigableMap');
import Spliterator = require('nashorn/java/util/Spliterator');
import AbstractMap = require('nashorn/java/util/AbstractMap');
import Cloneable = require('nashorn/java/lang/Cloneable');
import Serializable = require('nashorn/java/io/Serializable');
import AbstractSet = require('nashorn/java/util/AbstractSet');
import NavigableSet = require('nashorn/java/util/NavigableSet');
import AbstractCollection = require('nashorn/java/util/AbstractCollection');

declare class TreeMap<K, V> {
	constructor();
	constructor(arg1 : Comparator<any>);
	constructor(arg1 : Map<K, V>);
	constructor(arg1 : SortedMap<K, V>);
	getEntry(arg1 : Object) : TreeMap.Entry<K, V>;
	getEntryUsingComparator(arg1 : Object) : TreeMap.Entry<K, V>;
	getCeilingEntry(arg1 : K) : TreeMap.Entry<K, V>;
	getFloorEntry(arg1 : K) : TreeMap.Entry<K, V>;
	getHigherEntry(arg1 : K) : TreeMap.Entry<K, V>;
	getLowerEntry(arg1 : K) : TreeMap.Entry<K, V>;
	keyIterator() : Iterator<K>;
	descendingKeyIterator() : Iterator<K>;
	compare(arg1 : Object, arg2 : Object) : number;
	static valEquals(arg1 : Object, arg2 : Object) : boolean;
	static exportEntry<K, V>(arg1 : TreeMap.Entry<K, V>) : Map.Entry<K, V>;
	static keyOrNull<K, V>(arg1 : TreeMap.Entry<K, V>) : K;
	static key<K>(arg1 : TreeMap.Entry<K, any>) : K;
	getFirstEntry() : TreeMap.Entry<K, V>;
	getLastEntry() : TreeMap.Entry<K, V>;
	static successor<K, V>(arg1 : TreeMap.Entry<K, V>) : TreeMap.Entry<K, V>;
	static predecessor<K, V>(arg1 : TreeMap.Entry<K, V>) : TreeMap.Entry<K, V>;
	static colorOf<K, V>(arg1 : TreeMap.Entry<K, V>) : boolean;
	static parentOf<K, V>(arg1 : TreeMap.Entry<K, V>) : TreeMap.Entry<K, V>;
	static setColor<K, V>(arg1 : TreeMap.Entry<K, V>, arg2 : boolean) : void;
	static leftOf<K, V>(arg1 : TreeMap.Entry<K, V>) : TreeMap.Entry<K, V>;
	static rightOf<K, V>(arg1 : TreeMap.Entry<K, V>) : TreeMap.Entry<K, V>;
	rotateLeft(arg1 : TreeMap.Entry<K, V>) : void;
	rotateRight(arg1 : TreeMap.Entry<K, V>) : void;
	fixAfterInsertion(arg1 : TreeMap.Entry<K, V>) : void;
	deleteEntry(arg1 : TreeMap.Entry<K, V>) : void;
	fixAfterDeletion(arg1 : TreeMap.Entry<K, V>) : void;
	writeObject(arg1 : ObjectOutputStream) : void;
	readObject(arg1 : ObjectInputStream) : void;
	readTreeSet(arg1 : number, arg2 : ObjectInputStream, arg3 : V) : void;
	addAllForTreeSet(arg1 : SortedSet<K>, arg2 : V) : void;
	buildFromSorted(arg1 : number, arg2 : Iterator<any>, arg3 : ObjectInputStream, arg4 : V) : void;
	buildFromSorted(arg1 : number, arg2 : number, arg3 : number, arg4 : number, arg5 : Iterator<any>, arg6 : ObjectInputStream, arg7 : V) : TreeMap.Entry<K, V>;
	static computeRedLevel(arg1 : number) : number;
	static keySpliteratorFor<K>(arg1 : NavigableMap<K, any>) : Spliterator<K>;
	keySpliterator() : Spliterator<K>;
	descendingKeySpliterator() : Spliterator<K>;
}


declare interface TreeMap<K, V> extends AbstractMap<K, V>, NavigableMap<K, V>, Cloneable, Serializable {}

declare module TreeMap {
	class AscendingSubMap<K, V> {
	}


	interface AscendingSubMap<K, V> extends TreeMap.NavigableSubMap<K, V> {}

	module AscendingSubMap {
		class AscendingEntrySetView {
		}


		interface AscendingEntrySetView extends TreeMap.NavigableSubMap.EntrySetView {}	}
	class DescendingKeyIterator {
	}


	interface DescendingKeyIterator extends TreeMap.PrivateEntryIterator<K> {}	class DescendingKeySpliterator<K, V> {
	}


	interface DescendingKeySpliterator<K, V> extends TreeMap.TreeMapSpliterator<K, V>, Spliterator<K> {}	class DescendingSubMap<K, V> {
	}


	interface DescendingSubMap<K, V> extends TreeMap.NavigableSubMap<K, V> {}

	module DescendingSubMap {
		class DescendingEntrySetView {
		}


		interface DescendingEntrySetView extends TreeMap.NavigableSubMap.EntrySetView {}	}
	class Entry<K, V> {
		key : K;
		value : V;
	}


	interface Entry<K, V> extends Map.Entry<K, V> {}	class EntryIterator {
	}


	interface EntryIterator extends TreeMap.PrivateEntryIterator<Map.Entry<K, V>> {}	class EntrySet {
	}


	interface EntrySet extends AbstractSet<Map.Entry<K, V>> {}	class EntrySpliterator<K, V> {
		comparator : Comparator<Map.Entry<K, V>>;
	}


	interface EntrySpliterator<K, V> extends TreeMap.TreeMapSpliterator<K, V>, Spliterator<Map.Entry<K, V>> {}	class KeyIterator {
	}


	interface KeyIterator extends TreeMap.PrivateEntryIterator<K> {}	class KeySet<E> {
		empty : boolean;
	}


	interface KeySet<E> extends AbstractSet<E>, NavigableSet<E> {}	class KeySpliterator<K, V> {
		comparator : Comparator<any>;
	}


	interface KeySpliterator<K, V> extends TreeMap.TreeMapSpliterator<K, V>, Spliterator<K> {}	class NavigableSubMap<K, V> {
		empty : boolean;
		tooLow(arg1 : Object) : boolean;
		tooHigh(arg1 : Object) : boolean;
		inRange(arg1 : Object) : boolean;
		inClosedRange(arg1 : Object) : boolean;
		inRange(arg1 : Object, arg2 : boolean) : boolean;
		absLowest() : TreeMap.Entry<K, V>;
		absHighest() : TreeMap.Entry<K, V>;
		absCeiling(arg1 : K) : TreeMap.Entry<K, V>;
		absHigher(arg1 : K) : TreeMap.Entry<K, V>;
		absFloor(arg1 : K) : TreeMap.Entry<K, V>;
		absLower(arg1 : K) : TreeMap.Entry<K, V>;
		absHighFence() : TreeMap.Entry<K, V>;
		absLowFence() : TreeMap.Entry<K, V>;
		subLowest() : TreeMap.Entry<K, V>;
		subHighest() : TreeMap.Entry<K, V>;
		subCeiling(arg1 : K) : TreeMap.Entry<K, V>;
		subHigher(arg1 : K) : TreeMap.Entry<K, V>;
		subFloor(arg1 : K) : TreeMap.Entry<K, V>;
		subLower(arg1 : K) : TreeMap.Entry<K, V>;
		keyIterator() : Iterator<K>;
		keySpliterator() : Spliterator<K>;
		descendingKeyIterator() : Iterator<K>;
	}


	interface NavigableSubMap<K, V> extends AbstractMap<K, V>, NavigableMap<K, V>, Serializable {}

	module NavigableSubMap {
		class DescendingSubMapEntryIterator {
		}


		interface DescendingSubMapEntryIterator extends TreeMap.NavigableSubMap.SubMapIterator<Map.Entry<K, V>> {}		class DescendingSubMapKeyIterator {
		}


		interface DescendingSubMapKeyIterator extends TreeMap.NavigableSubMap.SubMapIterator<K>, Spliterator<K> {}		class EntrySetView {
			empty : boolean;
		}


		interface EntrySetView extends AbstractSet<Map.Entry<K, V>> {}		class SubMapEntryIterator {
		}


		interface SubMapEntryIterator extends TreeMap.NavigableSubMap.SubMapIterator<Map.Entry<K, V>> {}		class SubMapIterator<T> {
			nextEntry() : TreeMap.Entry<K, V>;
			prevEntry() : TreeMap.Entry<K, V>;
			removeAscending() : void;
			removeDescending() : void;
		}


		interface SubMapIterator<T> extends Iterator<T> {}		class SubMapKeyIterator {
			comparator : Comparator<any>;
		}


		interface SubMapKeyIterator extends TreeMap.NavigableSubMap.SubMapIterator<K>, Spliterator<K> {}	}
	class PrivateEntryIterator<T> {
		nextEntry() : TreeMap.Entry<K, V>;
		prevEntry() : TreeMap.Entry<K, V>;
	}


	interface PrivateEntryIterator<T> extends Iterator<T> {}	class SubMap {
		readResolve() : Object;
	}


	interface SubMap extends AbstractMap<K, V>, SortedMap<K, V>, Serializable {}	class TreeMapSpliterator<K, V> extends Object {
		getEstimate() : number;
		estimateSize() : number;
	}
	class ValueIterator {
	}


	interface ValueIterator extends TreeMap.PrivateEntryIterator<V> {}	class ValueSpliterator<K, V> {
	}


	interface ValueSpliterator<K, V> extends TreeMap.TreeMapSpliterator<K, V>, Spliterator<V> {}	class Values {
	}


	interface Values extends AbstractCollection<V> {}}

export = TreeMap
