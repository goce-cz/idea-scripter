import DoublePredicate = require('nashorn/java/util/function/DoublePredicate');
import DoubleUnaryOperator = require('nashorn/java/util/function/DoubleUnaryOperator');
import DoubleFunction = require('nashorn/java/util/function/DoubleFunction');
import Stream = require('nashorn/java/util/stream/Stream');
import DoubleToIntFunction = require('nashorn/java/util/function/DoubleToIntFunction');
import IntStream = require('nashorn/java/util/stream/IntStream');
import DoubleToLongFunction = require('nashorn/java/util/function/DoubleToLongFunction');
import LongStream = require('nashorn/java/util/stream/LongStream');
import DoubleConsumer = require('nashorn/java/util/function/DoubleConsumer');
import DoubleBinaryOperator = require('nashorn/java/util/function/DoubleBinaryOperator');
import OptionalDouble = require('nashorn/java/util/OptionalDouble');
import Supplier = require('nashorn/java/util/function/Supplier');
import ObjDoubleConsumer = require('nashorn/java/util/function/ObjDoubleConsumer');
import BiConsumer = require('nashorn/java/util/function/BiConsumer');
import DoubleSummaryStatistics = require('nashorn/java/util/DoubleSummaryStatistics');
import DoubleSupplier = require('nashorn/java/util/function/DoubleSupplier');
import BaseStream = require('nashorn/java/util/stream/BaseStream');

declare class DoubleStream {
	filter(arg1 : DoublePredicate) : DoubleStream;
	map(arg1 : DoubleUnaryOperator) : DoubleStream;
	mapToObj<U>(arg1 : DoubleFunction<U>) : Stream<U>;
	mapToInt(arg1 : DoubleToIntFunction) : IntStream;
	mapToLong(arg1 : DoubleToLongFunction) : LongStream;
	flatMap(arg1 : DoubleFunction<DoubleStream>) : DoubleStream;
	distinct() : DoubleStream;
	sorted() : DoubleStream;
	peek(arg1 : DoubleConsumer) : DoubleStream;
	limit(arg1 : number) : DoubleStream;
	skip(arg1 : number) : DoubleStream;
	forEach(arg1 : DoubleConsumer) : void;
	forEachOrdered(arg1 : DoubleConsumer) : void;
	toArray() : number[];
	reduce(arg1 : number, arg2 : DoubleBinaryOperator) : number;
	reduce(arg1 : DoubleBinaryOperator) : OptionalDouble;
	collect<R>(arg1 : Supplier<R>, arg2 : ObjDoubleConsumer<R>, arg3 : BiConsumer<R, R>) : R;
	sum() : number;
	min() : OptionalDouble;
	max() : OptionalDouble;
	count() : number;
	average() : OptionalDouble;
	summaryStatistics() : DoubleSummaryStatistics;
	anyMatch(arg1 : DoublePredicate) : boolean;
	allMatch(arg1 : DoublePredicate) : boolean;
	noneMatch(arg1 : DoublePredicate) : boolean;
	findFirst() : OptionalDouble;
	findAny() : OptionalDouble;
	boxed() : Stream<number>;
	static builder() : DoubleStream.Builder;
	static empty() : DoubleStream;
	static of(arg1 : number) : DoubleStream;
	static of(arg1 : number[]) : DoubleStream;
	static iterate(arg1 : number, arg2 : DoubleUnaryOperator) : DoubleStream;
	static generate(arg1 : DoubleSupplier) : DoubleStream;
	static concat(arg1 : DoubleStream, arg2 : DoubleStream) : DoubleStream;
}


declare interface DoubleStream extends BaseStream<number, DoubleStream> {}

declare module DoubleStream {
	class Builder {
		add(arg1 : number) : DoubleStream.Builder;
		build() : DoubleStream;
	}


	interface Builder extends DoubleConsumer {}}

export = DoubleStream
