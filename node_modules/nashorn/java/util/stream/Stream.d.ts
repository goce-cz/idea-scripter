import Predicate = require('nashorn/java/util/function/Predicate');
import Function = require('nashorn/java/util/function/Function');
import ToIntFunction = require('nashorn/java/util/function/ToIntFunction');
import IntStream = require('nashorn/java/util/stream/IntStream');
import ToLongFunction = require('nashorn/java/util/function/ToLongFunction');
import LongStream = require('nashorn/java/util/stream/LongStream');
import ToDoubleFunction = require('nashorn/java/util/function/ToDoubleFunction');
import DoubleStream = require('nashorn/java/util/stream/DoubleStream');
import Comparator = require('nashorn/java/util/Comparator');
import Consumer = require('nashorn/java/util/function/Consumer');
import Object = require('nashorn/java/lang/Object');
import IntFunction = require('nashorn/java/util/function/IntFunction');
import BinaryOperator = require('nashorn/java/util/function/BinaryOperator');
import Optional = require('nashorn/java/util/Optional');
import BiFunction = require('nashorn/java/util/function/BiFunction');
import Supplier = require('nashorn/java/util/function/Supplier');
import BiConsumer = require('nashorn/java/util/function/BiConsumer');
import Collector = require('nashorn/java/util/stream/Collector');
import UnaryOperator = require('nashorn/java/util/function/UnaryOperator');
import BaseStream = require('nashorn/java/util/stream/BaseStream');

declare class Stream<T> {
	filter(arg1 : Predicate<any>) : Stream<T>;
	map<R>(arg1 : Function<any, R>) : Stream<R>;
	mapToInt(arg1 : ToIntFunction<any>) : IntStream;
	mapToLong(arg1 : ToLongFunction<any>) : LongStream;
	mapToDouble(arg1 : ToDoubleFunction<any>) : DoubleStream;
	flatMap<R>(arg1 : Function<any, Stream<R>>) : Stream<R>;
	flatMapToInt(arg1 : Function<any, IntStream>) : IntStream;
	flatMapToLong(arg1 : Function<any, LongStream>) : LongStream;
	flatMapToDouble(arg1 : Function<any, DoubleStream>) : DoubleStream;
	distinct() : Stream<T>;
	sorted() : Stream<T>;
	sorted(arg1 : Comparator<any>) : Stream<T>;
	peek(arg1 : Consumer<any>) : Stream<T>;
	limit(arg1 : number) : Stream<T>;
	skip(arg1 : number) : Stream<T>;
	forEach(arg1 : Consumer<any>) : void;
	forEachOrdered(arg1 : Consumer<any>) : void;
	toArray() : Object[];
	toArray<A>(arg1 : IntFunction<A[]>) : A[];
	reduce(arg1 : T, arg2 : BinaryOperator<T>) : T;
	reduce(arg1 : BinaryOperator<T>) : Optional<T>;
	reduce<U>(arg1 : U, arg2 : BiFunction<U, any, U>, arg3 : BinaryOperator<U>) : U;
	collect<R>(arg1 : Supplier<R>, arg2 : BiConsumer<R, any>, arg3 : BiConsumer<R, R>) : R;
	collect<R, A>(arg1 : Collector<any, A, R>) : R;
	min(arg1 : Comparator<any>) : Optional<T>;
	max(arg1 : Comparator<any>) : Optional<T>;
	count() : number;
	anyMatch(arg1 : Predicate<any>) : boolean;
	allMatch(arg1 : Predicate<any>) : boolean;
	noneMatch(arg1 : Predicate<any>) : boolean;
	findFirst() : Optional<T>;
	findAny() : Optional<T>;
	static builder<T>() : Stream.Builder<T>;
	static empty<T>() : Stream<T>;
	static of<T>(arg1 : T) : Stream<T>;
	static of<T>(arg1 : T[]) : Stream<T>;
	static iterate<T>(arg1 : T, arg2 : UnaryOperator<T>) : Stream<T>;
	static generate<T>(arg1 : Supplier<T>) : Stream<T>;
	static concat<T>(arg1 : Stream<T>, arg2 : Stream<T>) : Stream<T>;
}


declare interface Stream<T> extends BaseStream<T, Stream<T>> {}

declare module Stream {
	class Builder<T> {
		add(arg1 : T) : Stream.Builder<T>;
		build() : Stream<T>;
	}


	interface Builder<T> extends Consumer<T> {}}

export = Stream
