import Object = require('nashorn/java/lang/Object');
import Set = require('nashorn/java/util/Set');
import Collection = require('nashorn/java/util/Collection');
import BiConsumer = require('nashorn/java/util/function/BiConsumer');
import BiFunction = require('nashorn/java/util/function/BiFunction');
import Function = require('nashorn/java/util/function/Function');
import Comparable = require('nashorn/java/lang/Comparable');
import Comparator = require('nashorn/java/util/Comparator');

declare class Map<K, V> extends Object {
	empty : boolean;
	size() : number;
	isEmpty() : boolean;
	containsKey(arg1 : Object) : boolean;
	containsValue(arg1 : Object) : boolean;
	get(arg1 : Object) : V;
	put(arg1 : K, arg2 : V) : V;
	remove(arg1 : Object) : V;
	putAll(arg1 : Map<K, V>) : void;
	clear() : void;
	keySet() : Set<K>;
	values() : Collection<V>;
	entrySet() : Set<Map.Entry<K, V>>;
	getOrDefault(arg1 : Object, arg2 : V) : V;
	forEach(arg1 : BiConsumer<any, any>) : void;
	replaceAll(arg1 : BiFunction<any, any, V>) : void;
	putIfAbsent(arg1 : K, arg2 : V) : V;
	remove(arg1 : Object, arg2 : Object) : boolean;
	replace(arg1 : K, arg2 : V, arg3 : V) : boolean;
	replace(arg1 : K, arg2 : V) : V;
	computeIfAbsent(arg1 : K, arg2 : Function<any, V>) : V;
	computeIfPresent(arg1 : K, arg2 : BiFunction<any, any, V>) : V;
	compute(arg1 : K, arg2 : BiFunction<any, any, V>) : V;
	merge(arg1 : K, arg2 : V, arg3 : BiFunction<any, any, V>) : V;
}


declare module Map {
	class Entry<K, V> extends Object {
		key : K;
		value : V;
		getKey() : K;
		getValue() : V;
		setValue(arg1 : V) : V;
		static comparingByKey<K extends Comparable<any>, V>() : Comparator<Map.Entry<K, V>>;
		static comparingByValue<K, V extends Comparable<any>>() : Comparator<Map.Entry<K, V>>;
		static comparingByKey<K, V>(arg1 : Comparator<any>) : Comparator<Map.Entry<K, V>>;
		static comparingByValue<K, V>(arg1 : Comparator<any>) : Comparator<Map.Entry<K, V>>;
	}
}

export = Map
