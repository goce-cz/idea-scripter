import Map = require('nashorn/java/util/Map');
import Object = require('nashorn/java/lang/Object');
import Class = require('nashorn/java/lang/Class');
import ObjectOutputStream = require('nashorn/java/io/ObjectOutputStream');
import ObjectInputStream = require('nashorn/java/io/ObjectInputStream');
import AbstractMap = require('nashorn/java/util/AbstractMap');
import Cloneable = require('nashorn/java/lang/Cloneable');
import Serializable = require('nashorn/java/io/Serializable');
import Iterator = require('nashorn/java/util/Iterator');
import AbstractSet = require('nashorn/java/util/AbstractSet');
import Spliterator = require('nashorn/java/util/Spliterator');
import LinkedHashMap = require('nashorn/java/util/LinkedHashMap');
import AbstractCollection = require('nashorn/java/util/AbstractCollection');

declare class HashMap<K, V> {
	empty : boolean;
	constructor(arg1 : number, arg2 : number);
	constructor(arg1 : number);
	constructor();
	constructor(arg1 : Map<K, V>);
	static hash(arg1 : Object) : number;
	static comparableClassFor(arg1 : Object) : Class<any>;
	static compareComparables(arg1 : Class<any>, arg2 : Object, arg3 : Object) : number;
	static tableSizeFor(arg1 : number) : number;
	putMapEntries(arg1 : Map<K, V>, arg2 : boolean) : void;
	getNode(arg1 : number, arg2 : Object) : HashMap.Node<K, V>;
	putVal(arg1 : number, arg2 : K, arg3 : V, arg4 : boolean, arg5 : boolean) : V;
	resize() : HashMap.Node<K, V>[];
	treeifyBin(arg1 : HashMap.Node<K, V>[], arg2 : number) : void;
	removeNode(arg1 : number, arg2 : Object, arg3 : Object, arg4 : boolean, arg5 : boolean) : HashMap.Node<K, V>;
	loadFactor() : number;
	capacity() : number;
	writeObject(arg1 : ObjectOutputStream) : void;
	readObject(arg1 : ObjectInputStream) : void;
	newNode(arg1 : number, arg2 : K, arg3 : V, arg4 : HashMap.Node<K, V>) : HashMap.Node<K, V>;
	replacementNode(arg1 : HashMap.Node<K, V>, arg2 : HashMap.Node<K, V>) : HashMap.Node<K, V>;
	newTreeNode(arg1 : number, arg2 : K, arg3 : V, arg4 : HashMap.Node<K, V>) : HashMap.TreeNode<K, V>;
	replacementTreeNode(arg1 : HashMap.Node<K, V>, arg2 : HashMap.Node<K, V>) : HashMap.TreeNode<K, V>;
	reinitialize() : void;
	afterNodeAccess(arg1 : HashMap.Node<K, V>) : void;
	afterNodeInsertion(arg1 : boolean) : void;
	afterNodeRemoval(arg1 : HashMap.Node<K, V>) : void;
	internalWriteEntries(arg1 : ObjectOutputStream) : void;
}


declare interface HashMap<K, V> extends AbstractMap<K, V>, Map<K, V>, Cloneable, Serializable {}

declare module HashMap {
	class EntryIterator {
	}


	interface EntryIterator extends HashMap.HashIterator, Iterator<Map.Entry<K, V>> {}	class EntrySet {
	}


	interface EntrySet extends AbstractSet<Map.Entry<K, V>> {}	class EntrySpliterator<K, V> {
	}


	interface EntrySpliterator<K, V> extends HashMap.HashMapSpliterator<K, V>, Spliterator<Map.Entry<K, V>> {}	class HashIterator extends Object {
		hasNext() : boolean;
		nextNode() : HashMap.Node<K, V>;
		remove() : void;
	}
	class HashMapSpliterator<K, V> extends Object {
		getFence() : number;
		estimateSize() : number;
	}
	class KeyIterator {
	}


	interface KeyIterator extends HashMap.HashIterator, Iterator<K> {}	class KeySet {
	}


	interface KeySet extends AbstractSet<K> {}	class KeySpliterator<K, V> {
	}


	interface KeySpliterator<K, V> extends HashMap.HashMapSpliterator<K, V>, Spliterator<K> {}	class Node<K, V> {
		key : K;
		value : V;
	}


	interface Node<K, V> extends Map.Entry<K, V> {}	class TreeNode<K, V> {
		root() : HashMap.TreeNode<K, V>;
		static moveRootToFront<K, V>(arg1 : HashMap.Node<K, V>[], arg2 : HashMap.TreeNode<K, V>) : void;
		find(arg1 : number, arg2 : Object, arg3 : Class<any>) : HashMap.TreeNode<K, V>;
		getTreeNode(arg1 : number, arg2 : Object) : HashMap.TreeNode<K, V>;
		static tieBreakOrder(arg1 : Object, arg2 : Object) : number;
		treeify(arg1 : HashMap.Node<K, V>[]) : void;
		untreeify(arg1 : HashMap<K, V>) : HashMap.Node<K, V>;
		putTreeVal(arg1 : HashMap<K, V>, arg2 : HashMap.Node<K, V>[], arg3 : number, arg4 : K, arg5 : V) : HashMap.TreeNode<K, V>;
		removeTreeNode(arg1 : HashMap<K, V>, arg2 : HashMap.Node<K, V>[], arg3 : boolean) : void;
		split(arg1 : HashMap<K, V>, arg2 : HashMap.Node<K, V>[], arg3 : number, arg4 : number) : void;
		static rotateLeft<K, V>(arg1 : HashMap.TreeNode<K, V>, arg2 : HashMap.TreeNode<K, V>) : HashMap.TreeNode<K, V>;
		static rotateRight<K, V>(arg1 : HashMap.TreeNode<K, V>, arg2 : HashMap.TreeNode<K, V>) : HashMap.TreeNode<K, V>;
		static balanceInsertion<K, V>(arg1 : HashMap.TreeNode<K, V>, arg2 : HashMap.TreeNode<K, V>) : HashMap.TreeNode<K, V>;
		static balanceDeletion<K, V>(arg1 : HashMap.TreeNode<K, V>, arg2 : HashMap.TreeNode<K, V>) : HashMap.TreeNode<K, V>;
		static checkInvariants<K, V>(arg1 : HashMap.TreeNode<K, V>) : boolean;
	}


	interface TreeNode<K, V> extends LinkedHashMap.Entry<K, V> {}	class ValueIterator {
	}


	interface ValueIterator extends HashMap.HashIterator, Iterator<V> {}	class ValueSpliterator<K, V> {
	}


	interface ValueSpliterator<K, V> extends HashMap.HashMapSpliterator<K, V>, Spliterator<V> {}	class Values {
	}


	interface Values extends AbstractCollection<V> {}}

export = HashMap
