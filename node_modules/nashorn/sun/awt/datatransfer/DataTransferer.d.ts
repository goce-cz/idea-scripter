import Object = require('nashorn/java/lang/Object');
import DataFlavor = require('nashorn/java/awt/datatransfer/DataFlavor');
import ToolkitThreadBlockedHandler = require('nashorn/sun/awt/datatransfer/ToolkitThreadBlockedHandler');
import Class = require('nashorn/java/lang/Class');
import Set = require('nashorn/java/util/Set');
import FlavorMap = require('nashorn/java/awt/datatransfer/FlavorMap');
import FlavorTable = require('nashorn/java/awt/datatransfer/FlavorTable');
import Transferable = require('nashorn/java/awt/datatransfer/Transferable');
import SortedMap = require('nashorn/java/util/SortedMap');
import Map = require('nashorn/java/util/Map');
import ArrayList = require('nashorn/java/util/ArrayList');
import ByteArrayOutputStream = require('nashorn/java/io/ByteArrayOutputStream');
import ProtectionDomain = require('nashorn/java/security/ProtectionDomain');
import File = require('nashorn/java/io/File');
import List = require('nashorn/java/util/List');
import InputStream = require('nashorn/java/io/InputStream');
import URI = require('nashorn/java/net/URI');
import Image = require('nashorn/java/awt/Image');
import RenderedImage = require('nashorn/java/awt/image/RenderedImage');
import Comparator = require('nashorn/java/util/Comparator');
import Constructor = require('nashorn/java/lang/reflect/Constructor');
import Method = require('nashorn/java/lang/reflect/Method');
import SortedSet = require('nashorn/java/util/SortedSet');

declare class DataTransferer extends Object {
	static plainTextStringFlavor : DataFlavor;
	static javaTextEncodingFlavor : DataFlavor;
	static instance : DataTransferer;
	static defaultTextCharset : string;
	defaultUnicodeEncoding : string;
	toolkitThreadBlockedHandler : ToolkitThreadBlockedHandler;
	constructor();
	static getInstance() : DataTransferer;
	static canonicalName(arg1 : string) : string;
	static getTextCharset(arg1 : DataFlavor) : string;
	static getDefaultTextCharset() : string;
	static doesSubtypeSupportCharset(arg1 : DataFlavor) : boolean;
	static doesSubtypeSupportCharset(arg1 : string, arg2 : string) : boolean;
	static isFlavorCharsetTextType(arg1 : DataFlavor) : boolean;
	static isFlavorNoncharsetTextType(arg1 : DataFlavor) : boolean;
	static isEncodingSupported(arg1 : string) : boolean;
	static isRemote(arg1 : Class<any>) : boolean;
	static standardEncodings() : Set<string>;
	static adaptFlavorMap(arg1 : FlavorMap) : FlavorTable;
	getDefaultUnicodeEncoding() : string;
	registerTextFlavorProperties(arg1 : string, arg2 : string, arg3 : string, arg4 : string) : void;
	isTextFormat(arg1 : number) : boolean;
	getCharsetForTextFormat(arg1 : number) : string;
	isLocaleDependentTextFormat(arg1 : number) : boolean;
	isFileFormat(arg1 : number) : boolean;
	isImageFormat(arg1 : number) : boolean;
	isURIListFormat(arg1 : number) : boolean;
	getFormatsForTransferable(arg1 : Transferable, arg2 : FlavorTable) : SortedMap<number, DataFlavor>;
	getFormatsForFlavor(arg1 : DataFlavor, arg2 : FlavorTable) : SortedMap;
	getFormatsForFlavors(arg1 : DataFlavor[], arg2 : FlavorTable) : SortedMap<number, DataFlavor>;
	getFormatsForTransferableAsArray(arg1 : Transferable, arg2 : FlavorTable) : number[];
	getFormatsForFlavorAsArray(arg1 : DataFlavor, arg2 : FlavorTable) : number[];
	getFormatsForFlavorsAsArray(arg1 : DataFlavor[], arg2 : FlavorTable) : number[];
	getFlavorsForFormat(arg1 : number, arg2 : FlavorTable) : Map;
	getFlavorsForFormats(arg1 : number[], arg2 : FlavorTable) : Map;
	getFlavorsForFormatsAsSet(arg1 : number[], arg2 : FlavorTable) : Set;
	getFlavorsForFormatAsArray(arg1 : number, arg2 : FlavorTable) : DataFlavor[];
	getFlavorsForFormatsAsArray(arg1 : number[], arg2 : FlavorTable) : DataFlavor[];
	static createMapping(arg1 : Object, arg2 : Object) : Object;
	getFormatForNativeAsLong(arg1 : string) : number;
	getNativeForFormat(arg1 : number) : string;
	getBestCharsetForTextFormat(arg1 : number, arg2 : Transferable) : string;
	translateTransferableString(arg1 : string, arg2 : number) : number[];
	translateBytesToString(arg1 : number[], arg2 : number, arg3 : Transferable) : string;
	translateTransferable(arg1 : Transferable, arg2 : DataFlavor, arg3 : number) : number[];
	static convertObjectToBytes(arg1 : Object) : number[];
	convertFileListToBytes(arg1 : ArrayList<string>) : ByteArrayOutputStream;
	removeSuspectedData(arg1 : DataFlavor, arg2 : Transferable, arg3 : string) : string;
	static getUserProtectionDomain(arg1 : Transferable) : ProtectionDomain;
	isForbiddenToRead(arg1 : File, arg2 : ProtectionDomain) : boolean;
	castToFiles(arg1 : List, arg2 : ProtectionDomain) : ArrayList<string>;
	castToFile(arg1 : Object) : File;
	static isFileInWebstartedCache(arg1 : File) : boolean;
	translateBytes(arg1 : number[], arg2 : DataFlavor, arg3 : number, arg4 : Transferable) : Object;
	translateStream(arg1 : InputStream, arg2 : DataFlavor, arg3 : number, arg4 : Transferable) : Object;
	translateStreamToInputStream(arg1 : InputStream, arg2 : DataFlavor, arg3 : number, arg4 : Transferable) : Object;
	constructFlavoredObject(arg1 : Object, arg2 : DataFlavor, arg3 : Class) : Object;
	dragQueryFile(arg1 : number[]) : string[];
	dragQueryURIs(arg1 : InputStream, arg2 : number, arg3 : Transferable) : URI[];
	platformImageBytesToImage(arg1 : number[], arg2 : number) : Image;
	standardImageBytesToImage(arg1 : number[], arg2 : string) : Image;
	imageToPlatformBytes(arg1 : Image, arg2 : number) : number[];
	imageToStandardBytes(arg1 : Image, arg2 : string) : number[];
	imageToStandardBytesImpl(arg1 : RenderedImage, arg2 : string) : number[];
	concatData(arg1 : Object, arg2 : Object) : Object;
	convertData(arg1 : Object, arg2 : Transferable, arg3 : number, arg4 : Map, arg5 : boolean) : number[];
	processDataConversionRequests() : void;
	getToolkitThreadBlockedHandler() : ToolkitThreadBlockedHandler;
	static keysToLongArray(arg1 : SortedMap) : number[];
	static setToSortedDataFlavorArray(arg1 : Set) : DataFlavor[];
	static inputStreamToByteArray(arg1 : InputStream) : number[];
	getPlatformMappingsForNative(arg1 : string) : List;
	getPlatformMappingsForFlavor(arg1 : DataFlavor) : List;
}


declare module DataTransferer {
	class CharsetComparator {
		constructor();
		constructor(arg1 : boolean);
		compareCharsets(arg1 : string, arg2 : string) : number;
		static getEncoding(arg1 : string) : string;
	}


	interface CharsetComparator extends DataTransferer.IndexedComparator {}	class DataFlavorComparator {
		constructor();
		constructor(arg1 : boolean);
	}


	interface DataFlavorComparator extends DataTransferer.IndexedComparator {}	class IndexOrderComparator {
		constructor(arg1 : Map);
		constructor(arg1 : Map, arg2 : boolean);
	}


	interface IndexOrderComparator extends DataTransferer.IndexedComparator {}	class IndexedComparator {
		static SELECT_BEST : boolean;
		static SELECT_WORST : boolean;
		constructor();
		constructor(arg1 : boolean);
		static compareIndices(arg1 : Map, arg2 : Object, arg3 : Object, arg4 : number) : number;
		static compareLongs(arg1 : Map, arg2 : Object, arg3 : Object, arg4 : number) : number;
	}


	interface IndexedComparator extends Comparator {}	class RMI extends Object {
		static getClass(arg1 : string) : Class<any>;
		static getConstructor(arg1 : Class<any>, arg2 : Class<any>[]) : Constructor<any>;
		static getMethod(arg1 : Class<any>, arg2 : string, arg3 : Class<any>[]) : Method;
		static isRemote(arg1 : Class<any>) : boolean;
		static remoteClass() : Class<any>;
		static newMarshalledObject(arg1 : Object) : Object;
		static getMarshalledObject(arg1 : Object) : Object;
	}
	class ReencodingInputStream {
		constructor(arg1 : InputStream, arg2 : number, arg3 : string, arg4 : Transferable);
		readChar() : number;
		matchCharArray(arg1 : string[], arg2 : number) : boolean;
	}


	interface ReencodingInputStream extends InputStream {}	class StandardEncodingsHolder extends Object {
		static load() : SortedSet<string>;
	}
}

export = DataTransferer
